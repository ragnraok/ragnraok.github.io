<!DOCTYPE html>
<html lang="zh">

<head>
            <meta charset="utf-8">
        <meta http-equiv="X-UA-Compatible" content="IE=edge">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="description" content="">
        <meta name="author" content="">

        <title>Ragnarok Note</title>

            <link href="https://ragnraok.github.io/feeds/atom.xml" type="application/atom+xml" rel="alternate" title="Ragnarok Note Full Atom Feed" />

        <!-- Bootstrap Core CSS -->
        <link href="https://ragnraok.github.io/theme/css/bootstrap.min.css" rel="stylesheet">

        <!-- Custom CSS -->
        <link href="https://ragnraok.github.io/theme/css/clean-blog.min.css" rel="stylesheet">

        <!-- Code highlight color scheme -->
            <link href="https://ragnraok.github.io/theme/css/code_blocks/darkly.css" rel="stylesheet">

        <!-- Custom Fonts -->
        <link href="http://maxcdn.bootstrapcdn.com/font-awesome/4.1.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">
        <link href='http://fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic' rel='stylesheet' type='text/css'>
        <link href='http://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800' rel='stylesheet' type='text/css'>

        <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
        <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
        <!--[if lt IE 9]>
            <script src="https://oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
            <script src="https://oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
        <![endif]-->






			<meta property="og:locale" content="zh">
		<meta property="og:site_name" content="Ragnarok Note">

	<meta property="og:type" content="article">
	<meta property="article:author" content="">
	<meta property="og:url" content="https://ragnraok.github.io/surface_display_lag.html">
	<meta property="og:title" content="浅谈Android中Surface显示延迟处理">
	<meta property="og:description" content="">
	<meta property="og:image" content="https://ragnraok.github.io/">
	<meta property="article:published_time" content="2018-06-20 00:00:00+08:00">
</head>

<body>

    <!-- Navigation -->
    <nav class="navbar navbar-default navbar-custom navbar-fixed-top">
        <div class="container-fluid">
            <!-- Brand and toggle get grouped for better mobile display -->
            <div class="navbar-header page-scroll">
                <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#bs-example-navbar-collapse-1">
                    <span class="sr-only">Toggle navigation</span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                    <span class="icon-bar"></span>
                </button>
                <a class="navbar-brand" href="https://ragnraok.github.io/">Ragnarok Note</a>
            </div>

            <!-- Collect the nav links, forms, and other content for toggling -->
            <div class="collapse navbar-collapse" id="bs-example-navbar-collapse-1">
                <ul class="nav navbar-nav navbar-right">

                </ul>
            </div>
            <!-- /.navbar-collapse -->
        </div>
        <!-- /.container -->
    </nav>

    <!-- Page Header -->
        <header class="intro-header" style="background-image: url('https://ragnraok.github.io/theme/images/post-bg.jpg')">
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <div class="post-heading">
                        <h1>浅谈Android中Surface显示延迟处理</h1>
                        <span class="meta">Posted by
                                <a href="https://ragnraok.github.io/author/ragnarok-zhou.html">Ragnarok Zhou</a>
                             on 三 20 六月 2018
                        </span>
                        
                    </div>
                </div>
            </div>
        </div>
    </header>

    <!-- Main Content -->
    <div class="container">
        <div class="row">
            <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
    <!-- Post Content -->
    <article>
        <p>最近在使用GLES在Surface上渲染结果的时候，遇到了一个显示延迟的问题，当渲染时间过长，同时帧率要求比较高的时候，如果不加控制，就会造成显示的延迟，如果界面没有交互，倒是不会看出什么问题，如果是强交互的场景，这种情况下就会造成可感知的用户使用延迟了。处理这种情况的其中一种方式是给渲染的一帧赋予一个时间戳，用于给SurfaceFlinger进行对应的丢帧控制，具体什么原理呢，让我们一步一步来说明一下</p>
<h3>Surface是什么？</h3>
<hr>
<p>从原来上讲，Android的 <a href="https://developer.android.com/reference/android/view/Surface">Surface</a> 可以认为是目前图形架构中，作为 <a href="https://source.android.com/devices/graphics/arch-bq-gralloc">BufferQueue</a> 的生产者端，Android会首先把内容渲染到Surface上，填充数据到GraphicBuffer上。而作为消费者端则为系统的<a href="https://source.android.com/devices/graphics/arch-sf-hwc">SurfaceFlinger</a> ，取出BufferQueue中的GraphicBuffer，并配合vysnc将数据送给HWC合成到屏幕上。</p>
<p>一般来说，Android会把所有可见的View渲染到一个由SurfaceFlinger创建的Surface上，但是这个Surface并不能由开发者直接操作，从App的开发角度来看，大部分情况下我们直接操作的Surface一般会从以下两个地方获取</p>
<ul>
<li>
<p><a href="https://developer.android.com/reference/android/view/SurfaceView">SurfaceView</a> / <a href="https://kapeli.com/dash_share?docset_file=Android&amp;docset_name=Android&amp;path=developer.android.com/reference/android/opengl/GLSurfaceView.html&amp;platform=android&amp;repo=Main&amp;source=https://developer.android.com/reference/android/opengl/GLSurfaceView.html&amp;version=8.1.0">GLSurfaceView</a></p>
<p>这两个组件是结合了Surface跟View的实现，特别的是，这两个view系统为其单独提供一层了Surface，并直接由SurfaceFlinger进行管理合成，因此实际显示在屏幕上的时候，并没有完全从属在当前的View的布局层次上，在布局对应的位置上，只是一个透明的占位符。而GLSurfaceView，则在SurfaceView的基础上提供了EGL的上下文，以便可以直接使用GLES在Surface上绘制内容</p>
</li>
<li>
<p><a href="https://developer.android.com/reference/android/graphics/SurfaceTexture">SurfaceTexture</a> / <a href="https://developer.android.com/reference/android/view/TextureView">TextureView</a></p>
<p>SurfaceTexture是从Android 3.0+开始提供的组件，提供了一个Surface跟GLES纹理的组合，而TextureView，则是一个SurfaceTexture跟View结合起来的组件。而TextureView跟SurfaceView最大的不同在于，虽然都是可以作为BufferQueue的生产方，但是最后合成的时候，并非由SurfaceFlinger直接合成，而是通过GLES直接合成到App对应的Surface上，在布局层次上是跟当前App的View是在同一个层级，对应的View的刷新逻辑也会影响TextureView。因此，从原理上来说，SurfaceView/GLSurfaceView的渲染效率要比TextureView要高</p>
</li>
</ul>
<h3>使用GLES在Surface中显示内容</h3>
<hr>
<p>上面说到，Surface作为BufferQueue的生产方，开发者可以在上面绘制画面，而在SurfaceView/TextureView上，系统都提供了对应的<code>lockCanvas</code>方法，返回一个<code>Canvas</code>对象允许在对应的Surface上绘制内容。除了这个方法以外，我们也可以使用GLES在Surface上绘制内容。</p>
<p>无论是使用GLSurfaceView，还是TextureView，使用GLES在Surface上绘制内容，我们都必须在单独线程进行GLES的上下文初始化（因为GL Context是跟线程绑定的），创建对应的<a href="https://source.android.com/devices/graphics/arch-egl-opengl">EGLSurface</a> ，一般来说，实现的代码如下（如果用的是GLSurfaceView，下面的初始化逻辑内部已经给你做好了）：</p>
<div class="highlight"><pre><span></span><code><span class="n">mEGLDisplay</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EGL14</span><span class="p">.</span><span class="na">eglGetDisplay</span><span class="p">(</span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_DEFAULT_DISPLAY</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">mEGLDisplay</span><span class="w"> </span><span class="o">===</span><span class="w"> </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_NO_DISPLAY</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;unable to get EGL14 display&quot;</span><span class="p">)</span>
<span class="p">}</span>
<span class="kd">val</span><span class="w"> </span><span class="nv">version</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntArray</span><span class="p">(</span><span class="m">2</span><span class="p">)</span>
<span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">EGL14</span><span class="p">.</span><span class="na">eglInitialize</span><span class="p">(</span><span class="n">mEGLDisplay</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">version</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="k">throw</span><span class="w"> </span><span class="n">RuntimeException</span><span class="p">(</span><span class="s">&quot;unable to initialize EGL14&quot;</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// Configure EGL for recording and OpenGL ES 2.0.</span>
<span class="kd">val</span><span class="w"> </span><span class="nv">attribList</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intArrayOf</span><span class="p">(</span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_RED_SIZE</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_GREEN_SIZE</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_BLUE_SIZE</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_ALPHA_SIZE</span><span class="p">,</span><span class="w"> </span><span class="m">8</span><span class="p">,</span>
<span class="w">                            </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_RENDERABLE_TYPE</span><span class="p">,</span><span class="w"> </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_OPENGL_ES2_BIT</span><span class="p">,</span><span class="w">                 </span>
<span class="w">                            </span><span class="n">EGL_RECORDABLE_ANDROID</span><span class="p">,</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span>
<span class="w">                            </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_NONE</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="nv">configs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">arrayOfNulls</span><span class="o">&lt;</span><span class="n">EGLConfig</span><span class="o">&gt;</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
<span class="kd">val</span><span class="w"> </span><span class="nv">numConfigs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">IntArray</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
<span class="n">EGL14</span><span class="p">.</span><span class="na">eglChooseConfig</span><span class="p">(</span><span class="n">mEGLDisplay</span><span class="p">,</span><span class="w"> </span><span class="n">attribList</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">configs</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">,</span><span class="w"> </span><span class="n">configs</span><span class="p">.</span><span class="na">size</span><span class="p">,</span><span class="w"> </span><span class="n">numConfigs</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="n">checkEglError</span><span class="p">(</span><span class="s">&quot;eglCreateContext RGB888+recordable ES2&quot;</span><span class="p">)</span>

<span class="c1">// Configure context for OpenGL ES 2.0.</span>
<span class="kd">val</span><span class="w"> </span><span class="nv">attrib_list</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intArrayOf</span><span class="p">(</span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_CONTEXT_CLIENT_VERSION</span><span class="p">,</span><span class="w"> </span><span class="m">2</span><span class="p">,</span><span class="w"> </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_NONE</span><span class="p">)</span>
<span class="n">mEGLContext</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EGL14</span><span class="p">.</span><span class="na">eglCreateContext</span><span class="p">(</span><span class="n">mEGLDisplay</span><span class="p">,</span><span class="w"> </span><span class="n">configs</span><span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_NO_CONTEXT</span><span class="p">,</span><span class="w"> </span><span class="n">attrib_list</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="n">checkEglError</span><span class="p">(</span><span class="s">&quot;eglCreateContext&quot;</span><span class="p">)</span>

<span class="c1">// Create a window surface, and attach it to the Surface we received.</span>
<span class="kd">val</span><span class="w"> </span><span class="nv">surfaceAttribs</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">intArrayOf</span><span class="p">(</span><span class="n">EGL14</span><span class="p">.</span><span class="na">EGL_NONE</span><span class="p">)</span>
<span class="n">mEGLSurface</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">EGL14</span><span class="p">.</span><span class="na">eglCreateWindowSurface</span><span class="p">(</span><span class="n">mEGLDisplay</span><span class="p">,</span><span class="w"> </span><span class="n">configs</span><span class="o">[</span><span class="m">0</span><span class="o">]</span><span class="p">,</span><span class="w"> </span><span class="n">mSurface</span><span class="p">,</span><span class="w"> </span><span class="n">surfaceAttribs</span><span class="p">,</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="n">checkEglError</span><span class="p">(</span><span class="s">&quot;eglCreateWindowSurface&quot;</span><span class="p">)</span>

<span class="n">EGL14</span><span class="p">.</span><span class="na">eglMakeCurrent</span><span class="p">(</span><span class="n">mEGLDisplay</span><span class="p">,</span><span class="w"> </span><span class="n">mEGLSurface</span><span class="p">,</span><span class="w"> </span><span class="n">mEGLSurface</span><span class="p">,</span><span class="w"> </span><span class="n">mEGLContext</span><span class="p">)</span>
<span class="n">checkEglError</span><span class="p">(</span><span class="s">&quot;eglMakeCurrent&quot;</span><span class="p">)</span>
</code></pre></div>

<p>以上代码摘自<a href="https://bigflake.com/mediacodec/CameraToMpegTest.java.txt">这里</a>，并转换成了kotlin</p>
<p>大概流程就是先选择好需要的EGL配置，然后初始化EGLConfig跟EGLContext，最终，调用<code>eglCreatexxxSurface</code>创建一个EGLSurface，这这个例子中调用的是<code>eglCreateWindowSurface</code>，并在函数中传入了SurfaceView/TextureView中的Surface对象````</p>
<p>另外，在<code>eglCreateWindowSurface</code>函数中传入的Surface对象，如果不是需要渲染到屏幕上的话，除了直接使用上面的两个Surface对象以外，在很多处理视频特效的应用中，另外一种方式是传入MediaCodec的Surface，也就是这个方法的返回结果</p>
<div class="highlight"><pre><span></span><code><span class="n">MediaCodec</span><span class="p">.</span><span class="na">getInputSurface</span>
</code></pre></div>

<p>然后MediaCodec作为编码器使用，渲染一帧之后结果就直接编码到结果视频中了</p>
<ul>
<li><em>这里简单在说明一点，在这种场景下（还有一种是使用GLES渲染camera preview），使用GLES渲染对应MediaCodec编码结果到Input Surface上的时候，使用的纹理类型必须是外部纹理（<code>GL_TEXTURE_EXTERNAL_OES</code>）</em></li>
</ul>
<p>在上面的初始化代码中，最终结果是创建了一个<code>EGLSurface</code>对象，这个对象最终会链接到Surface中的BufferQueue生产方接口，渲染到该EGLSurface上的新的一帧将会让一个GraphicBuffer离开队列并提供给消费者一方使用，但是，EGL并不会自动给提交当前渲染的一帧，当渲染好之后，需要调用<code>eglSwapBuffers</code>提交当前渲染结果，从而实现BufferQueue的刷新</p>
<p>结合SurfaceFlinger，使用GLES在Surface上渲染，上屏的整理流程大概如下：</p>
<p><strong>Surface -&gt; EGL renderer -&gt; swap buffer -&gt; BufferQueue deque -&gt; SurfaceFlinger -&gt; HWC -&gt; Display</strong></p>
<p>更具体的GraphicBuffer/BufferQueue同步机制，推荐看下<a href="https://blog.csdn.net/jinzhuojun/article/details/39698317">这篇</a>文章的分析</p>
<h3>Surface渲染上屏时间戳</h3>
<hr>
<p>上面大体分析了Surface原理，以及对应渲染上屏的步骤，但是，直到SurfaceFlinger，到Hareware Composer这一步，我们还有一个关键的问题没有解决：</p>
<p><strong>我们在渲染好一帧之后，如何能够保证这一帧的内容能够及时显示到屏幕上呢？</strong></p>
<p>或者换一个问法：</p>
<p><strong>当我们渲染一帧的时间过长的时候，我们又怎么能够保证在对应的时间点上在屏幕上显示对应的内容呢？</strong></p>
<p>如果没有解决这个问题，那么在游戏渲染，或者在视频播放渲染的时候，就很容易出现音视频不同步的情况。而Android对于这个问题的解决方式就是，让App去告诉SurfaceFlinger某一帧想要在哪个时间点显示到屏幕上，也就是说引入了帧时间戳的概念。当SurfaceFlinger提交到HWC超过这个时间戳的时候，就丢掉这一帧，如果还没达到对应帧的时间戳，就继续显示当前帧</p>
<p>而在实现上，Android提供了一个单独的EGL扩展：<a href="https://www.khronos.org/registry/EGL/extensions/ANDROID/EGL_ANDROID_presentation_time.txt">eglPresentationTimeANDROID</a> ，在swapBuffer之前调用，提交当前帧的想要的显示时间戳，至于时间戳的具体含义，在不同的场景中可能会有不同的表达，例如：</p>
<ul>
<li>
<p>如果是显示到屏幕上的时候，时间戳就是一个绝对时间值，例如系统的启动时间</p>
</li>
<li>
<p>如果是视频编码的场景，例如使用MediaCodec的InputSurface来编码视频的时候，这个时候时间戳的含义就是当前视频帧的 <a href="https://en.wikipedia.org/wiki/Presentation_timestamp">pts</a>，事实上，当你想在MediaCodec的InputSurface上渲染完内容之后，如果不调用这个函数控制当前这一帧的pts，除非合成器有额外控制，否则最后编码出来的视频fps将会相当大，具体这里的实现，可以参考下BigFlake这里的<a href="https://bigflake.com/mediacodec/EncodeAndMuxTest.java.txt">代码</a></p>
</li>
</ul>
<p><em>btw, 这个扩展对应的Android上层接口定义在<a href="https://developer.android.com/reference/android/opengl/EGLExt.html">这里</a></em></p>
<p>因此，通过对 <code>eglPresentationTimeANDROID</code> 的调用，结合BufferQueue，SurfaceFlinger就可以针对上屏的每一帧数据延迟做精确的控制了，假设说，我们设置了某一帧显示时间戳为<strong>T</strong>，然后提交到BufferQueue中：</p>
<ul>
<li>
<p>当在<strong>T-1</strong>的时间点，当前队首为这一帧的时候，SurfaceFlinger会继续hold住当前帧，也就是说这个时候显示的还是前一帧的数据</p>
</li>
<li>
<p>当达到了<strong>T</strong>时间点，当前队首为这一帧的时候，SurfaceFlinger便直接提交这一帧到Display</p>
</li>
<li>
<p>当达到了<strong>T+1</strong>时间点，当前队首为这一帧的时候，因为已经超过了这一帧设置的时间戳<strong>T</strong>，因此SurfaceFlinger便直接<strong>丢弃</strong>这一帧，继续处理队列剩余的帧数据</p>
</li>
</ul>
<p>总体来看，在通过帧时间戳控制之后，Android就可以解决Surface的渲染上屏延迟问题，但渲染过长的时候，就势必带来丢帧，因此根本的解决方案，还是得尽量在16ms内，渲染完一帧数据</p>
<p>文笔一般，水平有限，仅做抛砖引玉之用，欢迎更加仔细的讨论!</p>
<h3>References</h3>
<hr>
<ul>
<li>
<p><a href="https://stackoverflow.com/questions/26317132/minimize-android-glsurfaceview-lag/">StackOverFlow—Minimize Android GLSurfaceView Lag</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/jinzhuojun/article/details/39698317">Android中的GraphicBuffer同步机制-Fence</a></p>
</li>
<li>
<p><a href="https://www.khronos.org/registry/EGL/extensions/ANDROID/EGL_ANDROID_presentation_time.txt">EGL_ANDROID_presentation_time</a></p>
</li>
<li>
<p><a href="https://source.android.com/devices/graphics/">Android图形架构</a></p>
</li>
<li>
<p><a href="https://bigflake.com/mediacodec/">Android MediaCodec Stuff</a>````</p>
</li>
</ul>
    </article>

    <hr>

        <div class="comments">
            <h2>Comments !</h2>
            <div id="disqus_thread"></div>
            <script type="text/javascript">
                var disqus_shortname = 'ragnaroknote';
                var disqus_identifier = 'surface_display_lag.html';
                var disqus_url = 'https://ragnraok.github.io/surface_display_lag.html';
                (function() {
                    var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                    dsq.src = '//ragnaroknote.disqus.com/embed.js';
                    (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
                })();
            </script>
            <noscript>Please enable JavaScript to view the comments.</noscript>
        </div>
            </div>
        </div>
    </div>

    <hr>

    <!-- Footer -->
    <footer>
        <div class="container">
            <div class="row">
                <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
                    <ul class="list-inline text-center">
                        <li>
                            <a href="">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-twitter fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-facebook fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                        <li>
                            <a href="">
                                <span class="fa-stack fa-lg">
                                    <i class="fa fa-circle fa-stack-2x"></i>
                                    <i class="fa fa-github fa-stack-1x fa-inverse"></i>
                                </span>
                            </a>
                        </li>
                    </ul>
                    <p class="copyright text-muted">Blog powered by <a href="http://getpelican.com">Pelican</a>,
                which takes great advantage of <a href="http://python.org">Python</a>.</p>
                </div>
            </div>
        </div>
    </footer>

    <!-- jQuery -->
    <script src="https://ragnraok.github.io/theme/js/jquery.js"></script>

    <!-- Bootstrap Core JavaScript -->
    <script src="https://ragnraok.github.io/theme/js/bootstrap.min.js"></script>

    <!-- Custom Theme JavaScript -->
    <script src="https://ragnraok.github.io/theme/js/clean-blog.min.js"></script>

<script type="text/javascript">
    var disqus_shortname = 'ragnaroknote';
    (function () {
        var s = document.createElement('script'); s.async = true;
        s.type = 'text/javascript';
        s.src = '//' + disqus_shortname + '.disqus.com/count.js';
        (document.getElementsByTagName('HEAD')[0] || document.getElementsByTagName('BODY')[0]).appendChild(s);
    }());
</script>
</body>

</html>