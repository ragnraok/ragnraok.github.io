<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ragnarok Note</title><link href="/" rel="alternate"></link><link href="/feeds/atom.xml" rel="self"></link><id>/</id><updated>2015-12-20T00:00:00+08:00</updated><entry><title>RxCamera, 一个RxJava风格的android camera封装</title><link href="/rxcamera-introduce.html" rel="alternate"></link><updated>2015-12-20T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:,2015-12-20:rxcamera-introduce.html</id><summary type="html">&lt;p&gt;事实上这个库写了已经有一段时间了，由于最近工作上比较忙，所以现在才写一篇文章来总结&lt;/p&gt;
&lt;h3&gt;What's this&lt;/h3&gt;
&lt;p&gt;正如标题所说，&lt;a href="https://github.com/ragnraok/RxCamera"&gt;RxCamera&lt;/a&gt;是一个基于RxJava而构建的一套&lt;a href="http://developer.android.com/intl/es/reference/android/hardware/Camera.html"&gt;android.hardware.camera&lt;/a&gt;封装的库。最初写这个库的目的是为了熟悉RxJava，并且而且也看到虽然在android开发已经有不少基于RxJava的库，但是关于音视频相关却少之又少，于是就动手实现了一下。目前这个库还处于非常早期的状态，API比较简陋，并且关于camera的设置还有很多没有做&lt;/p&gt;
&lt;h3&gt;How to use&lt;/h3&gt;
&lt;p&gt;在&lt;a href="https://github.com/ragnraok/RxCamera"&gt;RxCamera&lt;/a&gt;的README中已经有关于这个库使用的比较详细介绍了，我在这里再说明一下：&lt;/p&gt;
&lt;h4&gt;加入依赖&lt;/h4&gt;
&lt;p&gt;首先你需要在项目中加入对RxCamera项目的依赖:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;repositories {
        jcenter()
}
dependencies {
    compile &amp;#39;com.ragnarok.rxcamera:lib:0.0.1&amp;#39;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;基本的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;配置camera的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;android的原生camera api提供了不少的选项来配置打开摄像头时候的参数，例如预览的帧率，预览的分辨率，自动对焦等，在RxCamera中主要是通过一个&lt;code&gt;RxCameraConfig&lt;/code&gt;对象来管理这些对象，并通过&lt;code&gt;RxCameraConfigChooser&lt;/code&gt;来配置对应参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    RxCameraConfig config = RxCameraConfigChooser.obtain().
        useBackCamera().
        setAutoFocus(true).
        setPreferPreviewFrameRate(15, 30).
        setPreferPreviewSize(new Point(640, 480)).
        setHandleSurfaceEvent(true).
        get();
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;打开摄像头并获取数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设置好参数之后，就可以直接打开摄像头了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    RxCamera.open(this, config).flatMap(new Func1&amp;lt;RxCamera, Observable&amp;lt;RxCamera&amp;gt;&amp;gt;() {
      @Override
      public Observable&amp;lt;RxCamera&amp;gt; call(RxCamera rxCamera) {
          return rxCamera.bindTexture(textureView);
          // or bind a SurfaceView:
          // rxCamera.bindSurface(SurfaceView)
      }
     }).flatMap(new Func1&amp;lt;RxCamera, Observable&amp;lt;RxCamera&amp;gt;&amp;gt;() {
        @Override
         public Observable&amp;lt;RxCamera&amp;gt; call(RxCamera rxCamera) {
            return rxCamera.startPreview();
         }
    });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里包括了设置用于预览的Surface(这里是使用&lt;code&gt;TextureView&lt;/code&gt;进行预览)，然后正式开始预览。&lt;/p&gt;
&lt;p&gt;只有预览之后才能开始获取摄像头的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;    &lt;span class="nt"&gt;camera&lt;/span&gt;&lt;span class="nc"&gt;.request&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="nc"&gt;.periodicDataRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nc"&gt;.subscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;Action1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;RxCameraData&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="n"&gt;Override&lt;/span&gt;
            &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;call&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;RxCameraData&lt;/span&gt; &lt;span class="n"&gt;rxCameraData&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="n"&gt;showLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;periodic request, cameraData.length: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;rxCameraData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cameraData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取摄像头的数据都通过&lt;code&gt;request&lt;/code&gt;来获取， RxCamera中封装了几种不同风格的cameraRequest，例如上面的是定时获取摄像头数据，每隔1000毫秒返回一次，另外还有连续返回数据，只返回一次数据等的request。这些request返回的Observable对象都会给订阅者返回&lt;code&gt;RxCameraData&lt;/code&gt;对象，其中包含两个字段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;byte[] cameraData&lt;/code&gt;，就是原生的摄像头数据，具体的数据格式，如果是从预览数据中获取，则是设置的previewFormat格式，没有设置则默认为YUV12。如果是takePictureRequest的话，则是返回JPEG格式的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Matrix rotateMatrix&lt;/code&gt;，这个Matrix可以帮助你把返回的摄像头数据旋转回在竖屏模式下正常显示，因为大部分android手机的安装角度都会90度或者270度，这样子在横屏拍摄的时候可以拿到正确的图像，但是在竖屏显示的时候就会被旋转过来，使用这个Matrix旋转获取到的摄像头数据之后，就可以获取到正确转向的图像了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;目前的状态&lt;/h3&gt;
&lt;p&gt;很明显这个库目前还处于非常早期的状态，API还比较简单，并且很多摄像头的参数也没有加入到进行设置，例如白平衡，闪光灯，测光等，后续这里将会逐渐完善丰富摄像头的各种设置。另外，由于是完全基于RxJava来构建的库，大部分接口都会直接返回Observable对象，这对于没有熟悉RxJava的人来说可能还是会有点距离，因此这里后续对接口的封装还是需要继续改进，对外可能不再暴露Observable对象&lt;/p&gt;
&lt;h3&gt;About camera2&lt;/h3&gt;
&lt;p&gt;熟悉android开发的人估计都已经知道在Lollipop，Google新增一套&lt;a href="http://developer.android.com/intl/es/reference/android/hardware/camera2/package-summary.html"&gt;camera2&lt;/a&gt;API用以取代之前的camera API，camera2提供了对摄像头更加精细化的控制，相对来说比起老的API，对摄像头的可控程度高了非常多。但我个人觉得新的API还不是特别好用，并且由于目前还是比较新，在使用新的camera2 API的时候，&lt;a href="http://source.android.com/devices/camera/versioning.html#camera_api2_capabilities_and_support_levels"&gt;还需要查询手机上有哪些特性是有实现的&lt;/a&gt;，目前使用起来相当麻烦。所以RxCamera暂时还不打算支持camera2&lt;/p&gt;</summary></entry><entry><title>Project Lacie Initiate</title><link href="/project-lacie-initiate.html" rel="alternate"></link><updated>2015-08-17T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:,2015-08-17:project-lacie-initiate.html</id><summary type="html">&lt;h3&gt;Motivation&lt;/h3&gt;
&lt;p&gt;我记得去年在组内介绍Annotation和&lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/"&gt;Annotation Process Tool&lt;/a&gt;的时候，当时不少小伙伴都认为这个是一个非常棒的工具，用来做代码生成非常合适，但是也存在不少问题，主要的争论点在于，对于大型的项目，其代码量非常大，无论是在IDE内或者在命令行中进行编译，即使只是普通的增量编译，打包，也需要耗上非常长的时间。而普通的APT则需要每次都先拉起一次编译过程，因为实际上整个Annotation Processing是Java编译中的一个&lt;a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html"&gt;步骤&lt;/a&gt;，另外如果在Annotation Processing的过程中另外产生了新的代码的话，还需要重新编译生成的代码，这会导致整个编译过程变得更加漫长，如下图，为Java源码编译的过程，摘自OpenJDK官网。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/javac-flow.png" /&gt;&lt;/p&gt;
&lt;p&gt;于是，后续我就逐渐开始想方法实现有一个类似Annotation Processor的API的工具，但并不需要拉起Javac进行编译，只需要输入源码即可，然后由开发者自行定义生成代码的规则，即可完成APT的功能。&lt;/p&gt;
&lt;h3&gt;Research&lt;/h3&gt;
&lt;p&gt;要实现这样的一个工具，最先迫切的就是需要一个语法解析器，这样子才能从源码中提取出所需要的信息。当时候的想法是自己来实现Tokenizer和Parser（真庆幸大学的时候教编译原理的灭绝大法师的训练，我还记得怎么写哈哈哈哈），但很快我就找到了&lt;a href="https://javacc.java.net/"&gt;JavaCC&lt;/a&gt;这个工具，这玩意可以说是Java编译器的生成工具，实际上Javac的前端也是这个东西来生成的。但是JavaCC生成的代码非常乱并且其API并不是很好用。当时候我想当JDK中一定是有单独Javac前端独立出来的，于是我又找到了JDK中的&lt;code&gt;tools.jar&lt;/code&gt;（OSX下这文件在&lt;code&gt;/Library/Java/JavaVirtualMachines/jdk_version/Contents/Home/lib&lt;/code&gt;可以找到），这玩意就是JDK的编译器前端，实现了Tokenizer和Parser，另外还实现了一套visitor模式的API，让使用者可以很方便的遍历整棵抽象语法树。这个库实在是太棒了，当时候就写了一篇&lt;a href="http://ragnraok.github.io/using-jdk-parser.html"&gt;文章&lt;/a&gt;来介绍这个库的使用。&lt;/p&gt;
&lt;h3&gt;Development&lt;/h3&gt;
&lt;p&gt;在了解了&lt;code&gt;tools.jar&lt;/code&gt;之后，我便开始了&lt;a href="https://github.com/ragnraok/JParserUtil"&gt;JParserUtil&lt;/a&gt;这个项目的开发，主要的目的在于利用&lt;code&gt;tools.jar&lt;/code&gt;，重新实现一套简单易用的API来获取源码的信息，例如类的名称，实现的接口信息，继承的类，包含了哪些方法，这些方法的名字，返回值，参数列表及其对应类型，类中变量的信息，名字，变量值的解析，变量的类型等。目前经过几个月的开发，基本上支持了以下的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供了一套API来提取源码库的信息，只需要输入源码的根目录，就会遍历递归解析&lt;/li&gt;
&lt;li&gt;提取代码中所声明类、Annotation、接口、枚举的信息，名称，修饰符，实现的接口，继承的类等&lt;/li&gt;
&lt;li&gt;提取类中声明变量的信息，变量的类型（支持提取类型的全限定名），修饰符，值的解析等&lt;/li&gt;
&lt;li&gt;提取类中方法的信息，方法签名，返回值等&lt;/li&gt;
&lt;li&gt;通过输入source map（可以从这个&lt;a href="https://github.com/ragnraok/JavaSourceMapGenerator"&gt;项目&lt;/a&gt;中生成），支持从&lt;code&gt;import *&lt;/code&gt;获取类的全限定名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更具体的支持以及对应的TODO，可以看下这里的&lt;a href="https://github.com/ragnraok/JParserUtil"&gt;README&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Another Beginning&lt;/h3&gt;
&lt;p&gt;目前&lt;a href="https://github.com/ragnraok/JParserUtil"&gt;JParserUtil&lt;/a&gt;项目已经大致完成，因此这个不用拉起编译期的Annotation Processor Tool项目也正式开始的，我将其命名为&lt;a href="https://github.com/ragnraok/Lacie"&gt;Projecct Lacie&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/lacie.jpg" /&gt;&lt;/p&gt;
&lt;p&gt;至于Lacie是谁，可以参考下&lt;a href="http://baike.baidu.com/view/9817779.htm?fromtitle=%E8%95%BE%E8%A5%BF&amp;amp;fromid=13003855&amp;amp;type=syn"&gt;蕾西·巴斯卡比鲁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目已经正式开始，正在处于快速的开发中，目前的road map大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供一套类似&lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html"&gt;AbstractProcessor&lt;/a&gt;以及对应的&lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html"&gt;ProcessingEnvironment&lt;/a&gt;，让开发者可以从原有的APT开发中顺利迁移过来。就目前来看，这套API并不算特别复杂，实现起来难度不大。&lt;/li&gt;
&lt;li&gt;由于JDK中ProcessingEnvironment的初始化是在编译过程中进行的，但我们这里并没有真正的拉起编译，因此还需要另外提供一套易用的接口来负责初始化整个环境。&lt;/li&gt;
&lt;li&gt;为了证明其可行性，打算另外实现一些使用APT编写的库，例如在android开发领域中大名鼎鼎的&lt;a href="https://github.com/excilys/androidannotations"&gt;AndroidAnnotations&lt;/a&gt;，&lt;a href="https://github.com/square/dagger"&gt;dagger&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;希望这个项目最后能被使用起来吧~，El Psy Congroo&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;OpenJDK主页关于Java源码编译过程的介绍：&lt;a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html"&gt;http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaCC主页：&lt;a href="https://javacc.java.net/"&gt;https://javacc.java.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;之前写关于&lt;code&gt;tools.jar&lt;/code&gt;的介绍：&lt;a href="http://ragnraok.github.io/using-jdk-parser.html"&gt;http://ragnraok.github.io/using-jdk-parser.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</summary></entry><entry><title>TextView预渲染研究</title><link href="/textview-pre-render-research.html" rel="alternate"></link><updated>2015-07-26T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:,2015-07-26:textview-pre-render-research.html</id><summary type="html">&lt;p&gt;Android中的TextView是整个framework中最复杂的控件之一，负责Android中显示文本的大部分工作，framwork中的许多控件也直接或者间接的继承于TextView，例如Button，EditText等。其内部实现也相当复杂，单论代码行数来说，android-22中TextView有足足9509行，另外，TextView中许多操作都非常繁重，例如&lt;code&gt;setText&lt;/code&gt;操作，需要设置SpanWatcher，或者需要重现创建一个SpannableString，还需要根据情况重新创建Text Layout，这些操作加起来之后令一次setText操作非常耗时。为了提升TextView的渲染效率，最近研究了一下预渲染的方法，接下来给大家讲解一下原理。&lt;/p&gt;
&lt;h3&gt;TextView渲染基本原理&lt;/h3&gt;
&lt;p&gt;首先来介绍下TextView的基本渲染原理，总的来说，TextView中负责渲染文字的主要是这三个类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/BoringLayout.html"&gt;BoringLayout&lt;/a&gt; &lt;br /&gt;
    主要负责显示单行文本，并提供了isBoring方法来判断是否满足单行文本的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/DynamicLayout.html"&gt;DynamicLayout&lt;/a&gt; &lt;br /&gt;
    当文本为Spannable的时候，TextView就会使用它来负责文本的显示，在内部设置了SpanWatcher，当检测到span改变的时候，会进行reflow，重新计算布局。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/StaticLayout.html"&gt;StaticLayout&lt;/a&gt; &lt;br /&gt;
    当文本为非单行文本，且非Spannable的时候，就会使用StaticLayout，内部并不会监听span的变化，因此效率上会比DynamicLayout高，只需一次布局的创建即可，但其实内部也能显示SpannableString，只是不能在span变化之后重新进行布局而已。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，以上三个类都继承于&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/Layout.html"&gt;Layout&lt;/a&gt;类，在此类中统一负责文本的具体绘制，在Layout.draw方法中，会对文本一行一行的进行渲染：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;TextLine&lt;/span&gt; &lt;span class="n"&gt;tl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TextLine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;obtain&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Draw the lines, one at a time.&lt;/span&gt;
&lt;span class="c1"&gt;// The baseline is the top of the following line minus the current line&amp;#39;s descent.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;firstLine&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;lastLine&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="o"&gt;....&lt;/span&gt;
      &lt;span class="n"&gt;Directions&lt;/span&gt; &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getLineDirections&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;DIRS_ALL_LEFT_TO_RIGHT&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;mSpannedText&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;hasTabOrEmoji&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
         &lt;span class="c1"&gt;// XXX: assumes there&amp;#39;s nothing additional to be done&lt;/span&gt;
          &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;drawText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lbaseline&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;paint&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;set&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paint&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;directions&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hasTabOrEmoji&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tabStops&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ltop&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lbaseline&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lbottom&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TextLine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;recycle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出来对于Spannble，或者包含emoji的文本的话，实际渲染操作是交给了&lt;code&gt;TextLine&lt;/code&gt;去绘制，否则直接使用&lt;code&gt;canvas.drawText&lt;/code&gt;，&lt;code&gt;TextLine&lt;/code&gt;负责单行复杂文本的绘制，其中Spannable, Emoji之类的绘制逻辑都包含在里面，TextLine的绘制逻辑也并非十分高效，这里后续将会继续说明其应该如何优化。&lt;/p&gt;
&lt;h3&gt;TextLayoutCache&lt;/h3&gt;
&lt;p&gt;Canvas在&lt;code&gt;drawText&lt;/code&gt;的时候，如果需要每次都计算字体的大小，边距等之类的话，就会非常耗时，导致drawText时间会拉的很长，为了提高效率，android在4.0之后引入了TextLayoutCache，使用LRU Cache缓存了字形，边距等数据，提升了drawText的速度，在4.4中，这个cache的大小是0.5M，全局使用，并且会在Activity的&lt;code&gt;configurationChanged&lt;/code&gt;, &lt;code&gt;onResume&lt;/code&gt;, &lt;code&gt;lowMemory&lt;/code&gt;, &lt;code&gt;updateVisibility&lt;/code&gt;等时机，会调用&lt;code&gt;Canvas.freeTextLayoutCache&lt;/code&gt;来释放这部分内存。由于这部分的cache是系统底层控制的，我们无法做具体的控制。&lt;/p&gt;
&lt;h3&gt;TextView的预渲染优化&lt;/h3&gt;
&lt;p&gt;从TextView的渲染原理来看，如果只是单纯的显示文本，我们根本不需要另外设置SpanWatcher来监听span的变化，因此我们可以直接使用BoringLayout或者StaticLayout来直接显示文本内容，但是BoringLayout只能显示单行文本，因此这里最好的选择是直接用StaticLayout&lt;/p&gt;
&lt;p&gt;我们选择了自定义View，并希望最终有这样的一个接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StaticLayoutView&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Layout&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setLayout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Layout&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;requestLayout&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;save&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;restore&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以直接通过设置这个view的Layout来绘制文本，并在&lt;code&gt;onDraw&lt;/code&gt;方法中直接使用这个Layout对象来绘制文本。在这里我们摒弃了&lt;code&gt;setText&lt;/code&gt;方法，直接通过Layout来绘制文本，而这里的Layout对象，我们可以通过预先创建之后才设置进去（这里可以放到单独的一个线程中创建），这样对比起普通TextView的&lt;code&gt;setText&lt;/code&gt;方法，我们减少了&lt;code&gt;setText&lt;/code&gt;中的许多消耗，可以大幅度的提升效率。&lt;/p&gt;
&lt;p&gt;StaticLayout的创建非常简单，只需要给定文本，宽度等就能直接创建。另外，为了预先填充TextLayoutCache，我们也可以在创建完StaticLayout对象之后，预先在一个dummy canvas中draw出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;StaticLayout&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StaticLayout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TestSpan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSpanString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;textPaint&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hardCodeWidth&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alignment&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyCanvas&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;性能对比&lt;/h3&gt;
&lt;p&gt;接下来我们测试一下具体的性能，这里的testcase放到了Github上：&lt;a href="https://github.com/ragnraok/StaticLayoutView"&gt;StaticLayoutView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;testcase的内容为，在一个ListView中，显示300个Item，每个item都是一段纯文本，里面全都是包含有大量ImageSpan的SpannableString，进行两边的对比，一边是直接使用StaticLayout，一边是使用普通的TextView，并且这300段文本不全相同，长度不同，随机生成，在StaticLayout的testcase中，StaticLayout都是预先在另外一个线程创建好之后才设置进去的，另外SpannableString也是预先生成好的。&lt;/p&gt;
&lt;p&gt;另外，在这里为了模拟真实app繁重的后台工作，另外创建了3个线程，不停在做浮点预算以尝试抢占CPU资源。&lt;/p&gt;
&lt;p&gt;测量性能的指标为，ListView连续向下滚动，测量其平均帧率为多少，分别测量五次，计算其平均值，最终性能测试结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/staticLayoutPerformance.png" /&gt;&lt;/p&gt;
&lt;p&gt;这里测试的机器是MX3，左侧是直接使用StaticLayout的方案，右侧是系统的默认方案，Y轴是FPS，可以看出来，使用优化之后的方案，帧率提升了许多。&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://instagram-engineering.tumblr.com/post/114508858967/improving-comment-rendering-on-android"&gt;Improving Comment Rendering on Android&lt;/a&gt;   &lt;br /&gt;
这篇文章介绍了Instagram如何优化他们的TextView渲染的效率，这也是这里优化方法的来源，Instagram也是直接使用StaticLayout并通过预先创建Layout的方法来减少了ListView滚动过程中的掉帧率，并且效果非常显著。这篇文章算是给出了这里的原理解析以及一个简单的实现&lt;/p&gt;</summary></entry><entry><title>使用Kotlin进行Android开发</title><link href="/using-kotlin-to-write-android-app.html" rel="alternate"></link><updated>2015-06-24T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:,2015-06-24:using-kotlin-to-write-android-app.html</id><summary type="html">&lt;h3&gt;What is Kotlin&lt;/h3&gt;
&lt;p&gt;Kotlin，原意是在俄罗斯的一个&lt;a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%89%B9%E6%9E%97%E5%B3%B6"&gt;小岛&lt;/a&gt;，JetBrain在2011年推出了以这个来命名的一个运行在JVM上的语言， 看上去有点类似C#和Scala的结合，并且同为静态类型，作为一门JVM上的语言，可以轻松兼容Java，并且整个语言设计的非常轻量。目前的版本为&lt;code&gt;0.12.200&lt;/code&gt;，尚未发布正式版。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;Kotlin的下载和配置在其&lt;a href="http://kotlinlang.org/docs/tutorials/getting-started.html"&gt;官网&lt;/a&gt;上有，在这里就不再赘述了，值得一提的是，作为JetBrains家出品的语言，自家的IDEA当然全力支持！&lt;/p&gt;
&lt;h3&gt;基本语法介绍&lt;/h3&gt;
&lt;p&gt;Kotlin的语法非常简洁，熟悉Java或者Scala的人都可以快速上手：&lt;/p&gt;
&lt;h4&gt;函数声明：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fun foo(va: Int): Int {
    return 1
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以单行声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fun foo(va: Int): Int = 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;lambda当然也是支持的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var c = {foo: Int -&amp;gt; println(foo)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin中的函数是一等对象，自然支持高阶函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var c = {foo: Int -&amp;gt; println(foo)}
fun fooTest(func: (Int)-&amp;gt;()) = println(&amp;quot;I&amp;#39;m Groot&amp;quot;)    
fooTest(c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;类与接口&lt;/h4&gt;
&lt;p&gt;类可以这样进行声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Bar&lt;/span&gt;(&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;b:&lt;/span&gt; &lt;span class="nb"&gt;Int&lt;/span&gt;): &lt;span class="n"&gt;Foo&lt;/span&gt;() {
    &lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; = &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="n"&gt;init&lt;/span&gt; {
        &lt;span class="n"&gt;println&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;class initializer&amp;quot;&lt;/span&gt;)
    }

    &lt;span class="n"&gt;constructor&lt;/span&gt;(): &lt;span class="n"&gt;this&lt;/span&gt;(&lt;span class="mi"&gt;1&lt;/span&gt;) {
        &lt;span class="n"&gt;println&lt;/span&gt;(&lt;span class="s"&gt;&amp;quot;secondary constructor&amp;quot;&lt;/span&gt;)
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bar类在这里继承了Foo类，Bar类有两个构造函数，直接在Bar类头的是primary constructor，另外一个构造函数使用&lt;code&gt;constructor&lt;/code&gt;关键字定义，注意必须要先调用primary constructor，另外，&lt;code&gt;init&lt;/code&gt;标明的是class initializer，每个构造函数都会首先调用class initializer里面的代码，再调用构造函数&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Inner class:&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Outer&lt;/span&gt; {
    &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;Inner&lt;/span&gt; {      
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin同样支持嵌套的内部类，不过和Java不一样的是，Kotlin的内部类不会默认包含一个指向外部类对象的引用，也就是说，Kotlin中所有的内部类默认就是&lt;strong&gt;静态&lt;/strong&gt;的，这样可以减少很多内存泄露的问题。另外，如果需要在内部类中引用外部类对象，可以在Inner类的声明前加上&lt;code&gt;inner&lt;/code&gt;关键字，然后在Inner类中使用标记的&lt;code&gt;this&lt;/code&gt;：&lt;code&gt;this@Outer&lt;/code&gt;来指向外部类对象&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Singleton:&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;object Single {
    var c = 1

    fun foo() = println(&amp;quot;foo&amp;quot;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin中使用&lt;code&gt;object&lt;/code&gt;关键字声明一个singleton对象，后面这里的方法就可以直接使用&lt;code&gt;Single.foo()&lt;/code&gt;来调用了&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Interface:&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;interface Interface {
    fun foo() {
        println(1)
    }
    fun bar()
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin中的interface，跟其他语言的&lt;code&gt;trait&lt;/code&gt;非常像，而且也可以带有默认的实现方法，并且不允许通过属性来维护状态。事实上，在上个版本中，interface的原来名称是&lt;code&gt;trait&lt;/code&gt;，而在M12现在这个版本中又改成了interface而已&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;Null safe and Smart type cast&lt;/h4&gt;
&lt;h5&gt;Null safe:&lt;/h5&gt;
&lt;p&gt;在Kotlin中，严格区分了nullable和非nullable对象，甚至在编译期解决了不少潜在的空指针问题:&lt;/p&gt;
&lt;p&gt;我们先来看下普通的变量声明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var c: String = &amp;quot;12123&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里声明了一个String对象，其值为"12123"，我们可以正常的使用这个对象的成员方法：&lt;code&gt;c.length()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是，如果在初始化的时候，变量c为空的话，这样声明就是错误的，会编译不过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var c: String = null
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确的声明应该是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var c: String? = null
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里在&lt;code&gt;String&lt;/code&gt;后面加多了一个问号，表明这里是一个&lt;strong&gt;Nullable&lt;/strong&gt;的对象，说明这个变量在使用的过程中&lt;strong&gt;可能为空&lt;/strong&gt;，而且，在调用这个变量的成员的时候，必须要使用这种语法：&lt;code&gt;c?.length()&lt;/code&gt;，在调用的时候添加了一个问号，表明，如果&lt;code&gt;c&lt;/code&gt;为空的时候，&lt;code&gt;length()&lt;/code&gt;这个方法就不会调用。coffe-script也有类似的，这种语法糖减少了很多平时用到的Null-checked，简化了代码，而且从编译器开始介入null-checked，大大减少了潜在的&lt;code&gt;NullPointerException&lt;/code&gt;，而事实上，null的确也是一个&lt;strong&gt;&lt;a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare"&gt;billion dollar mistake&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常年进行如此的调用语法常常会很恼人，因此在你进行显式的Null-checked的时候，Kotlin的编译器会认为后续的调用已经无需进行Null-checked，可以直接调用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;if (c != null) {
    c.length()
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Smart type cast&lt;/h5&gt;
&lt;p&gt;在Kotlin中，进行强制类型转换可以使用&lt;code&gt;as&lt;/code&gt;关键字，但有可能会抛出异常，因此，Kotlin引入了smart type cast:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;if (c is String) {
    c.length()
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上面的例子中，如果&lt;code&gt;c&lt;/code&gt;是一个String对象，则在if块中，可以直接使用String的方法，编译器会智能的帮你识别出c在if-blcok里面是一个String对象&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;Pattern Matching&lt;/h4&gt;
&lt;p&gt;Kotlin在一定程度上支持了一些FP的特性，包括强大的Pattern Matching，在Kotlin中可以使用&lt;code&gt;when&lt;/code&gt;关键字：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var x = 3
when (x) {
    1 -&amp;gt; print(&amp;quot;x == 1&amp;quot;)
    2 -&amp;gt; print(&amp;quot;x == 2&amp;quot;)
    in 1..10 -&amp;gt; print(&amp;quot;x is in the range&amp;quot;)
    !in 10..20 -&amp;gt; print(&amp;quot;x is outside the range&amp;quot;)
    is Int -&amp;gt; println(&amp;quot;is int&amp;quot;)
    else -&amp;gt; { // Note the block
      print(&amp;quot;x is neither 1 nor 2&amp;quot;)
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;Function Extension&lt;/h4&gt;
&lt;p&gt;在Java中我们经常需要给系统的类添加一些实用的方法，但苦于不能直接扩展，于是就有了各种的xxxUtils类，导致代码非常恶心，但是在Kotlin中，我们可以直接扩展库里面类的方法，通过function extension:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;fun String.fucker() {
    println(&amp;quot;a fucker&amp;quot;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面给&lt;code&gt;String&lt;/code&gt;类添加了一个fucker方法，我们可以直接使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&amp;quot;123123&amp;quot;.fucker()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这大大的减少了我们写xxxUtils类的必要性&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;配置使用Kotlin进行Android开发&lt;/h3&gt;
&lt;p&gt;使用Kotlin开发Android app的配置非常简单，按照&lt;a href="http://kotlinlang.org/docs/tutorials/kotlin-android.html"&gt;官方给出的配置即可&lt;/a&gt;，直接在Gradle的配置文件build.gradle中添加一个依赖：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="x"&gt;compile &amp;quot;org.jetbrains.kotlin:kotlin-stdlib:&lt;/span&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;kotlin_version&lt;/span&gt;&lt;span class="x"&gt;&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后添加Kotlin插件的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;apply plugin: &amp;#39;kotlin-android&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进行一次Gradle Sync之后，就可以直接在项目使用Kotlin编写代码了，另外，如果安装了Intellij的Kotlin插件，可以选择
&lt;code&gt;Tools-&amp;gt;Kotlin-&amp;gt;Configure Kotlin in Project&lt;/code&gt;，就可以自动进行上述的配置，一步到位&lt;/p&gt;
&lt;p&gt;我写了一个简单的Demo app放到了Github上，有兴趣可以看下使用Kotlin开发android app具体是怎样的：&lt;a href="https://github.com/ragnraok/MovieCamera"&gt;Demo地址&lt;/a&gt;&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;对于dex方法数目的影响&lt;/h3&gt;
&lt;p&gt;dex有个65535方法数的限制，这对Android开发造成了很大的影响，在使用Kotlin进行android app开发的时候，需要将Kotlin的标准库打包进入apk中，这意味着如果标准库过大，对分包会造成很大的限制（因为这必须得打包在主dex中），所幸的是，Kotlin的哲学是“Java中有的，就尽量复用，不再自行创造一套”，使得整个Kotlin的标准库非常小，我们可以简单将Kotlin的标准库和其他比较常用库进行一下对比：&lt;/p&gt;
&lt;table border="1" cellpadding="5"&gt;
    &lt;tr&gt;
        &lt;td&gt; 包名&lt;/td&gt;
        &lt;td&gt;android-support-v13.jar&lt;/td&gt;
        &lt;td&gt;android-support-v4.jar&lt;/td&gt;
        &lt;td&gt;android-support-v7-appcompat.jar&lt;/td&gt;
        &lt;td&gt;guava-18.0.jar&lt;/td&gt;
        &lt;td&gt;scala-library-2.12.0-M1.jar&lt;/td&gt;
        &lt;td&gt;kotlin-stdlib-0.12.213.jar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;方法数&lt;/td&gt;
        &lt;td&gt;8219&lt;/td&gt;
        &lt;td&gt;8118&lt;/td&gt;
        &lt;td&gt;4624&lt;/td&gt;
        &lt;td&gt;14833&lt;/td&gt;
        &lt;td&gt;51248&lt;/td&gt;
        &lt;td&gt;7228&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
可以看出来Kotlin的标准库相当小，只有7000多个方法，比support-v13和support-v4还小，这体现了Kotlin的设计哲学之一："100% interoperable with Java"，基本上Java已经有的，Kotlin会尽量复用。而对比来看，同样是JVM上的语言，我们也可以选择使用Scala来进行Android开发，但Scala标准库有5万多个方法，全部打包进主dex中，很容易就导致app爆主dex了。所以综合来看，轻量形的Kotlin还是相当适合进行Android开发的。&lt;/p&gt;
&lt;hr /&gt;
&lt;h3&gt;Project Anko&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/JetBrains/anko"&gt;Anko&lt;/a&gt; 是JetBrains推出的一个简化Android开发的库，同样由Kotlin来编写，主要的革命在于，声明UI的方式，完全抛弃了xml的使用，使用Anko，声明UI是这样做的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val customStyle = { v: Any -&amp;gt;
        when (v) {
            is Button -&amp;gt; v.textSize = 26f
            is EditText -&amp;gt; v.textSize = 24f
        }
    }

    verticalLayout {

        padding = dip(34)
        imageView(android.R.drawable.ic_menu_manage).layoutParams {
            margin = dip(16)
            gravity = Gravity.CENTER
        }

         val name = editText {
             hintResource = R.string.name
        }
        val password = editText {
            hintResource = R.string.password
            inputType = TYPE_CLASS_TEXT or TYPE_TEXT_VARIATION_PASSWORD
        }

        button(&amp;quot;Log in&amp;quot;) {
            onClick {
                tryLogin(name.text, password.text)
            }
        }
    }.style(customStyle)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你没看错，的确是在Activity类的onCreate方法中直接声明UI的布局。&lt;/p&gt;
&lt;p&gt;Anko看起来像是使用了一种类似DSL的方式声明了界面的UI，这里主要是使用了Kotlin的其中两个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function Extension，Anko扩展了Activity类，提供了额外的方法和属性&lt;/li&gt;
&lt;li&gt;Kotlin在调用函数的时候，如果最后一个参数为函数的话，则可以直接使用Lambda，并省略括号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此这里声明布局的方式，其实全是Kotlin的原生代码，鹅妹子嘤！这样做有显然的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于实际上全是由代码来布局，省去了解析xml的时间&lt;/li&gt;
&lt;li&gt;xml本身有许多缺点，例如不可重用，非类型安全等，使用代码布局的话，我们可以很容易的就解决这个问题了&lt;/li&gt;
&lt;/ul&gt;
&lt;hr /&gt;
&lt;h3&gt;Other References:&lt;/h3&gt;
&lt;p&gt;这里列出一些国外的关于Kotlin的介绍文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?hl=zh-CN&amp;amp;forcehl=1"&gt;Using Project Kotlin for Android&lt;/a&gt; Square的JakeWharton曾经考察过几种不同的语言来进行Android开发，最后还是认为Kotlin比较优秀&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.gouline.net/2014/08/31/kotlin-the-swift-of-android/"&gt;Kotlin, the Swift of Android&lt;/a&gt; 这篇文章把Kotlin比喻为Android上的swift，虽然比较老，但是也可以看做Kotlin的介绍性文章&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>使用JDK的Parser来解析Java源代码</title><link href="/using-jdk-parser.html" rel="alternate"></link><updated>2015-04-12T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:,2015-04-12:using-jdk-parser.html</id><summary type="html">&lt;p&gt;在JDK中，自带了一套相关的编译API，可以在Java中发起编译流程，解析Java源文件然后获取其语法树，在JDK的&lt;code&gt;tools.jar&lt;/code&gt;（OSX下可以在/Library/Java/JavaVirtualMachines/jdk_version/Contents/Home/lib中找到）中包含着这整套API，但是这却不是Oracle和OpenJDK发布中的公开API，因此对于这套API，并没有官方的正式文档来进行说明。但是，也有不少项目利用了这套API来做了不少事情，例如大名鼎鼎的&lt;a href="https://github.com/rzwitserloot/lombok.git"&gt;lombok&lt;/a&gt;使用了这套API在Annotation Processing阶段修改了源代码中的语法树，最终结果相当于直接在源文件中插入了新的代码！&lt;/p&gt;
&lt;p&gt;由于这套API目前缺少相关文档，使用起来比较困难，例如，解析源代码中的所有变量，并打印出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="kr"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;final&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="nx"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;User.java&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;JavacFileManager&lt;/span&gt; &lt;span class="nx"&gt;fileManager&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;JavacTool&lt;/span&gt; &lt;span class="nx"&gt;javacTool&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Context&lt;/span&gt; &lt;span class="nx"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nx"&gt;fileManager&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;JavacFileManager&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Charset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;defaultCharset&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="nx"&gt;javacTool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;JavacTool&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;parseJavaFiles&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;JavaFileObject&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;fileManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getJavaFileObjects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;path&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="nx"&gt;JavaCompiler&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CompilationTask&lt;/span&gt; &lt;span class="nx"&gt;compilationTask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;javacTool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getTask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;fileManager&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="nx"&gt;JavacTask&lt;/span&gt; &lt;span class="nx"&gt;javacTask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;JavacTask&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;compilationTask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;CompilationUnitTree&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;javacTask&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;CompilationUnitTree&lt;/span&gt; &lt;span class="nx"&gt;tree&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;SourceVisitor&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;IOException&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SourceVisitor&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;TreeScanner&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Void&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;String&lt;/span&gt; &lt;span class="nx"&gt;currentPackageName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;Override&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;visitCompilationUnit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;CompilationUnitTree&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;        
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;visitCompilationUnit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;Override&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;visitVariable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;VariableTree&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;variable name: %s, type: %s, kind: %s, package: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                    &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getType&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getKind&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;currentPackageName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="nx"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt; &lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="nx"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parseJavaFiles&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 &lt;code&gt;User.java&lt;/code&gt;的代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ragnarok&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;javaparser&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sun.istack.internal.Nullable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.lang.Override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Nullable&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;123123&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;UserMethod&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;fooString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;123123&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;FooMethod&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行上面的&lt;code&gt;JavaParser&lt;/code&gt;结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;annotaion&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Nullable&lt;/span&gt;
&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;VARIABLE&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;package&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ragnarok&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;javaparser&lt;/span&gt;
&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;VARIABLE&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;package&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ragnarok&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;javaparser&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里我们是首先通过&lt;code&gt;JavaCompiler.CompilationTask&lt;/code&gt;解析了源文件之后，再使用自定义的&lt;code&gt;SourceVisitor&lt;/code&gt;（继承自&lt;code&gt;TreeScanner&lt;/code&gt;）来对源代码的结构进行访问，在&lt;code&gt;SourceVisitor&lt;/code&gt;类中，通过重载&lt;code&gt;visitVariable&lt;/code&gt;来对一个编译单元（单个源代码文件）进行解析，访问其中的所有的变量，这里可以看出，我们没有办法拿到这个变量类型的全限定名（包含包名），只能拿到的对应的简单名字，因此，类型的确定需要外部实现&lt;strong&gt;自行确定&lt;/strong&gt;，例如可以通过记录类所在的包名，递归的搜索整个源代码目录来跟踪所有类的全限定名，查找import中是否包含对应的类型等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TreeScanner&lt;/code&gt;中除了&lt;code&gt;visitVariable&lt;/code&gt;方法外，还包含了大量其他的&lt;code&gt;visitXYZ&lt;/code&gt;方法，例如，可以遍历所有的import，方法定义，Annotation等，更具体可以查看OpenJDK中关于这个的源代码&lt;/p&gt;
&lt;p&gt;这里再来看下另外一个例子，重载&lt;code&gt;visitClass&lt;/code&gt;方法，访问所有的内部类以及类本身：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;Override&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;visitClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ClassTree&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;class name: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getSimpleName&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Tree&lt;/span&gt; &lt;span class="nx"&gt;member&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getMembers&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;member&lt;/span&gt; &lt;span class="k"&gt;instanceof&lt;/span&gt; &lt;span class="nx"&gt;VariableTree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;VariableTree&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;VariableTree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;member&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="nx"&gt;List&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;AnnotationTree&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;annotations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getModifiers&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getAnnotations&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;annotations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;variable: %s, annotaion: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;annotations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getAnnotationType&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;variable: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;                
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;visitClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里简单的打印了类名以及变量的名称，类型，annotation类型，执行上面的代码，结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;name:&lt;/span&gt; &lt;span class="n"&gt;User&lt;/span&gt;
&lt;span class="n"&gt;variable:&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;, &lt;span class="n"&gt;annotaion:&lt;/span&gt; &lt;span class="n"&gt;Nullable&lt;/span&gt;
&lt;span class="n"&gt;variable:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;
&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="n"&gt;name:&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt;
&lt;span class="n"&gt;variable:&lt;/span&gt; &lt;span class="n"&gt;fooString&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出我们把类名以及类中的变量都打印了出来。而在&lt;code&gt;visitClass&lt;/code&gt;方法中，我们可以通过&lt;code&gt;getMembers&lt;/code&gt;方法拿到类中所有的成员，包括变量，方法，annotation等，分别对应着不同的类型，例如变量就对应着&lt;code&gt;VariableTree&lt;/code&gt;类型，方法就对应的&lt;code&gt;MethodTree&lt;/code&gt;类型。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;总得来说，虽然实际上使用并不算特别复杂，但是由于缺少文档，对使用造成了很大的障碍，而且目前所介绍的只是这套API的一少部分，后续我将会继续研究这套API的相关函数。&lt;/p&gt;</summary></entry><entry><title>探索在Android中使用Emoji Font的方法</title><link href="/android-emoji-font-method.html" rel="alternate"></link><updated>2015-01-14T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:,2015-01-14:android-emoji-font-method.html</id><summary type="html">&lt;p&gt;先说结论，在android4.4以前，无法使用像苹果那样的emoji字体样式，最简单的解决方案是使用ImageSpan配合SpannableString，而在4.4及之后的版本，则可以直接采用类似iOS/OSX的方案进行快速渲染。&lt;/p&gt;
&lt;h3&gt;Apple Color Emoji&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E7%B9%AA%E6%96%87%E5%AD%97"&gt;Emoji&lt;/a&gt;表情，最初是从日本的“绘文字”演化过来，在没有正式定下规范之前，日本的三大电信运营商，NTT DoCoMo，au/KDDI，Softbank都各自有一套关于Emoji的编码规范，而且在这个时候，每个Emoji表情对应的表情图片也是没有统一规范的。这时候，应用最广泛的是应该的属于日本软银（Softbank）的Softbank编码了，在iOS系统的早期的版本上，采用的也是这个编码规范。&lt;/p&gt;
&lt;p&gt;后来，在2010年10月，随着Unicode6.0的发布，Emoji的编码以及对应的表情图片正式被规范化，核心Emoji表情包含722个Emoji编码。而到了Unicode 7.0（2014年6月发行）之后，更多的Emoji表情被加入了进来，包括一些其他比较偏门的Emoji表情组，例如&lt;a href="http://en.wikipedia.org/wiki/Webdings"&gt;Webdings&lt;/a&gt;，&lt;a href="http://en.wikipedia.org/wiki/Wingdings"&gt;Wingdings&lt;/a&gt;，也被编入了Unicode 7.0规范，此时，整个Emoji编码集合已经有大概1000个左右，而在表情图片的规范上，除了我们常见的ios style之外，还有Android Style，Twitter Style等，在&lt;a href="http://apps.timwhitlock.info/emoji/tables/unicode"&gt;这里&lt;/a&gt;，有一份比较详细的Emoji表情列表，包含了不同的表情样式以及对应的编码。&lt;/p&gt;
&lt;p&gt;而在iOS系统上，在Unicode 6.0规范出来之前，原来也是采用Softbank编码（iOS 4以及之前版本），而Unicode 6.0规范之后（iOS 5以及之后的版本，或者OSX Lion之后的系统），则改为使用了Unicode编码。&lt;/p&gt;
&lt;p&gt;那么，iOS/OSX是怎么把这些Emoji表情渲染出来的呢？&lt;/p&gt;
&lt;p&gt;在OSX 10.7之后，OSX引入Color Emoji，这是苹果第一次在自己的桌面操作系统引入Emoji，用户可以直接在Mail或者iMessage之类的客户端直接输入Emoji字符。OSX（其实iOS也是用基本相同的实现）上的实现是通过一个叫做Apple Color Emoji的字体来实现的，这个字体文件被放在了&lt;code&gt;/System/Library/Fonts/Apple Color Emoji.ttf&lt;/code&gt;目录中。关于这个字体的细节，在Typophile中曾经有进行过相关的&lt;a href="http://typophile.com/node/83760"&gt;讨论&lt;/a&gt;，最后有工程师使用逆向工程分析了这个字体文件的格式，得出来的结论是，苹果扩展了OpenType标准，在ttf文件中直接嵌入了包含Emoji表情的图片，然后输入的时候通过根据Emoji表情的Unicode编码，找到对应的图片，将表情渲染出来。&lt;/p&gt;
&lt;p&gt;国外的程序员总是不用加班，因此他们很有空的研究了Apple Color Emoji的具体实现。前面提到，有工程逆向分析了Apple Color Emoji的采用的技术，下面我们来具体操作一下，最后我们可以提取出&lt;code&gt;Apple Color Emoji.ttf&lt;/code&gt;中的所有Emoji图片，以下的流程来自Typophile的一篇&lt;a href="http://typophile.com/node/103268"&gt;文章&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装FontTools，这是一个将ttf文件转换成xml，或者将xml转换成ttf文件的工具，使用python编写，如果已经安装了pip，可以通过&lt;code&gt;pip install FontTools&lt;/code&gt;来安装。&lt;/li&gt;
&lt;li&gt;上述文章中作者提供了一个FontTools的扩展，叫做&lt;code&gt;sbix_code.zip&lt;/code&gt;，&lt;a href="http://www.kutilek.de/download/sbix_code.zip"&gt;下载&lt;/a&gt;之后解压缩，将里面的文件复制到FontTools在python的site-packages目录下，如果是在OSX上，假设你使用的是python 2.7，那一般是在&lt;code&gt;/Library/Python/2.7/site-packages/FontTools&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;该作者还提供了一个使用的demo：&lt;a href="http://www.kutilek.de/download/sbix_demo.zip"&gt;sbix_demo.zip&lt;/a&gt;，解压缩之后编辑里面的&lt;code&gt;extractSbixImages.py&lt;/code&gt;，修改如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#! /usr/bin/env/python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fontTools.ttLib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TTFont&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;os.path&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;makedirs&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TTFont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Apple Color Emoji.ttf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sbix&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;sbix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;sbix&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sbix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bitmapSets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;itervalues&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="n"&gt;setpath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;extracted&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;set_&lt;/span&gt;&lt;span class="si"&gt;%i&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setpath&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;makedirs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setpath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Writing bitmap set to &amp;lt;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;setpath&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;bm&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bitmaps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;itervalues&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;bm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imageFormatTag&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setpath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s"&gt;.png&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;bm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;glyphName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;pf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;wb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imageData&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;Font has no sbix table.&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;"Apple Color Emoji.ttf"&lt;/code&gt;请改成Apple Color Emoji.ttf这个文件对应的目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行脚本，然后我们看到在同目录下多了一个叫做&lt;code&gt;extracted&lt;/code&gt;文件夹，里面分别存放着不同分辨率的Emoji表情图片：&lt;br /&gt;
&lt;img alt="" src="static/images/emojiFontList.png" /&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;set_**&lt;/code&gt;目录分辨对应不同的分辨率，可以看出，&lt;code&gt;Apple Color Emoji.ttf&lt;/code&gt;这个字体内嵌了多达8中不同分辨率的Emoji图片，难怪这个字体文件的大小达到了34M。&lt;/p&gt;
&lt;p&gt;非常感谢这位程序员的工作，使得我们能够一窥这个字体的大致实现，但是很可惜，这个实现是苹果自己的私有标准，没有合入到OpenType的正式标准中，而苹果官方对这里的实现也没有更多的资料，所以具体的技术标准，目前暂时找不到更加详细的资料。&lt;/p&gt;
&lt;h3&gt;Google Extension&lt;/h3&gt;
&lt;p&gt;Google一直以来都是程序员的救星，在Apple Color Emoji推出多年之后，在2013年，Google终于也推出了自己的开源Color Font标准：&lt;a href="http://google-opensource.blogspot.sg/2013/05/open-standard-color-font-fun-for.html"&gt;Open Standard Font Fun for Everyone
&lt;/a&gt;，Google同样扩展了OpenType的标准，并且提供了一个开源的实现：&lt;a href="https://code.google.com/p/color-emoji/"&gt;color-emoji&lt;/a&gt;。Google通过以下方式扩展OpenType，使其支持Color Emoji:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复用在ttf文件结构中的EBDT/EBLC表，直接内嵌Emoji图片的ARGB信息到这两个表当中，根据Google的标准，目前采用的是每个像素24位来存储，以BGRA顺序存储。值得一提的是，在ttf文件中，这两个表本来就是设计用于内嵌图片数据的，用于小分辨率字体的渲染，本来一般每像素只用8位存储，因此只能存储黑白图片，详细可以看下微软的官方&lt;a href="http://www.microsoft.com/typography/otspec/ebdt.htm"&gt;资料&lt;/a&gt;，不过在这种情况下，内嵌的图片是未经压缩的。&lt;/li&gt;
&lt;li&gt;另外一种方法是Google在ttf文件中新增了两个表，叫做CBDT/CBLC，在这两个表中可以存储经过压缩的图片格式，目前只支持PNG这一种格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;注：ttf文件的格式大致是以表为单位存储各种不同的数据，关于ttf文件的格式，可以查看微软的官方&lt;a href="http://www.microsoft.com/typography/otspec/otff.htm"&gt;资料&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;可以看出，Google的实现大致也苹果的类似，都是内嵌了图片在ttf文件中。而在Google提供的开源实现当中，主要包括以下几个项目的扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;freetype的扩展，Google扩展了freetype这个库，使其支持Google的ttf扩展&lt;/li&gt;
&lt;li&gt;skia，支持freetype扩展之后的字体解析输出&lt;/li&gt;
&lt;li&gt;cairo，支持了freetype扩展之后的输出，并且对于不能渲染的状况，fallback成使用Xlib作为后端(cairo也是和skia一样的2D矢量绘图库，可以选择多个后端，例如选择OpenGL为后端可以实现硬件加速)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，这个项目的freetype以及skia的实现被带入了Android 4.4中，也就是说，在Android 4.4之后的版本，我们终于可以像iOS一样使用Color Emoji Font了！！&lt;/p&gt;
&lt;h3&gt;Using in Android&lt;/h3&gt;
&lt;p&gt;上文提到，在Android 4.4之后，Google终于支持了Color Emoji Font，实际上，如果你用的是Google输入法，则可以发现在这个面板上输入到所有Google Style的Emoji表情：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/googleIME.png" /&gt; &lt;/p&gt;
&lt;p&gt;但是，很明显，Google提供的Emoji字体的样式实在是太丑了，很多人还是喜欢原来苹果的Emoji样式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/iosEmoji.jpg" /&gt; &lt;/p&gt;
&lt;p&gt;既然Android 4.4之后新增了Color Emoji Font的支持，根据上面的叙述，我们是否可以自己制作一个iOS Style Emoji字体给我们使用呢，答案当然是可以了，在xda论坛上，已经有人进行了这种&lt;a href="http://forum.xda-developers.com/showthread.php?t=2563757"&gt;尝试&lt;/a&gt;，原理是利用OSX中的&lt;code&gt;Apple Color Emoji.ttf&lt;/code&gt;提取出来的图片，然后使用FontTools以及&lt;a href="https://code.google.com/p/color-emoji/"&gt;color-emoji&lt;/a&gt;项目中的相关脚本即可生成对应的ttf文件。&lt;/p&gt;
&lt;p&gt;由于整个生成过程比较复杂，涉及比较多的依赖，有兴趣的可以看下color-emoji项目中的example的Makefile文件的内容，可以看到每一步是怎么生成的，在这里由于篇幅有限就不再赘述了。根据此方法生成的ttf文件，大家可以在这里&lt;a href="http://pan.baidu.com/s/1kTLyqSB"&gt;下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在生成了这个emoji字体文件之后，我们就可以直接在android中使用了，有以下两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root了手机之后，更改系统的字体配置文件，使其作为系统的默认emoji字体。&lt;/li&gt;
&lt;li&gt;在TextView中使用setTypeface来设置字体，只要TextView中包含的内容含有emoji指定的unicode编码，就可以直接显示emoji表情了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;性能对比&lt;/h4&gt;
&lt;p&gt;对比起使用SpannableString那一套，直接通过setTypeface来显示emoji文字的性能差距究竟有多少呢？接下来我们来简单的测试一下。&lt;/p&gt;
&lt;p&gt;在测试用例的选择方面，我们选择一条3000多行的emoji表情字符串，算是一个非常极端例子（每个表情后面跟上一个换行符）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/emojiFontTestCase.png" /&gt;&lt;/p&gt;
&lt;p&gt;测试基准为，从&lt;code&gt;startActivity&lt;/code&gt;开始，到包含表情的Activity的中展示emoji的TextView第一次调用&lt;code&gt;dispatchDraw&lt;/code&gt;方法为止所消耗的时间，测试的环境为Nexus 5，Android 5.0，测试10次，计算平均时间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Emoji Font，平均时间为&lt;strong&gt;433ms&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用SpannableString（不带cache），平均时间为&lt;strong&gt;9457ms&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果SpannableString带上cache之后，可以省去了重复setSpan的耗时了，此时的平均时间为&lt;strong&gt;8357ms&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，Emoji Font比SpannableString的方案快了一个数量级，而且即使带上cache，使用SpannableString出来的效果也没有想象中好，究其原因，或许是由于在绘制时，getSpans操作中的反射消耗了大量时间。&lt;/p&gt;
&lt;h4&gt;Backport to pre-KitKat&lt;/h4&gt;
&lt;p&gt;Color Emoji Font是Android4.4才加上的新功能，那对于4.4之前的版本，有没有办法也能使用Emoji Font呢，我想到了两点，但似乎都不大可行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将skia和freetype带入app中，使用其中的API去解析，然后构建一个Typeface给TextView使用。先不讨论是否可行，首先skia编译出来的so已经是非常大了，skia官方的android app demo中的的&lt;code&gt;libskia_android.so&lt;/code&gt;大小达到&lt;strong&gt;36M&lt;/strong&gt;，完全不可能放在普通app中。&lt;/li&gt;
&lt;li&gt;重造TextView，自行解析emoji符号，不使用SpannableString，而是直接画出来。使用这个方案之后，Emoji Font就不是必须的了，但重造TextView的成本也是太高了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，最终的结论仍然是开头中所说的，在android4.4以前，无法使用像iOS/OSX那样的Emoji Font，最简单的解决方案是使用ImageSpan配合SpannableString，而在4.4及之后的版本，则可以直接采用类似iOS/OSX的方案进行快速渲染。&lt;/p&gt;
&lt;hr /&gt;
&lt;p&gt;最后，祝愿Lollipop的光芒能够早日照亮天朝。&lt;/p&gt;</summary></entry><entry><title>Re:Blog</title><link href="/re-blog.html" rel="alternate"></link><updated>2015-01-02T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:,2015-01-02:re-blog.html</id><summary type="html">&lt;p&gt;大二的时候，曾经写过一段时间的博客。当时还记得刚学python不久，兴高采烈的使用Django写了一个非常简单的博客引擎，在42qu买了个服务器，然后在Godaddy那里买了个域名，于是就火速在上面搭建了人生的第一个博客。&lt;/p&gt;
&lt;p&gt;一晃过去，已经是两年的时间了，原来的博客早已废弃，已经很久没有在博客上写过文字了。&lt;/p&gt;
&lt;p&gt;工作半年，这半年工作真的非常忙。越来越觉得缺少积累，而且慢慢地，也失去了当初在学校那种涉猎各种技术的激情，反而，作为Android开发者，在Android开发这里，进行了更加深入的研究。这让我想起了以前在学校有位老师跟我说过，在学校需要的时候更广的知识面，而到了工作，就需要更为深入的专研某个技术的实现，而对于Android以外的技术，已经没有那么多时间再去涉猎了，这或许是从BFS到DFS的转变吧。&lt;/p&gt;
&lt;p&gt;在以前的博客，即使我成功地实现了某个函数也会记录下来，在这里，除了技术，或许我会在这里记录一些生活的细节吧。&lt;/p&gt;
&lt;p&gt;思绪混乱，文笔一般，看客请注意。&lt;/p&gt;
&lt;p&gt;已经是2015年了，新的一年，希望通过这个博客，能够有个新的开始吧。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：此博客由&lt;a href="https://github.com/getpelican/pelican"&gt;pelican&lt;/a&gt;搭建&lt;/em&gt;&lt;/p&gt;</summary></entry></feed>