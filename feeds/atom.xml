<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Ragnarok Note</title><link href="http://ragnraok.github.io/" rel="alternate"></link><link href="http://ragnraok.github.io/feeds/atom.xml" rel="self"></link><id>http://ragnraok.github.io/</id><updated>2019-08-28T00:00:00+08:00</updated><entry><title>尝试在Android中实现PBR管线——环境光照明</title><link href="http://ragnraok.github.io/try_android_implement_pbr_ambient_lighting.html" rel="alternate"></link><published>2019-08-28T00:00:00+08:00</published><updated>2019-08-28T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2019-08-28:/try_android_implement_pbr_ambient_lighting.html</id><summary type="html">&lt;p&gt;在上一篇文章中，我们讨论了PBR管线的基础理论，以及实现了场景中直接光（点光源/方向光源）照明的计算，对比与Blinn-Phong模型，PBR使用了微平面理论来对现实世界建模，而在BRDF项计算中，使用了法线分布函数/几何函数/菲涅尔方程构成的BRDF方程来计算光线对某种材质最终输出光照的影响。&lt;/p&gt;
&lt;p&gt;但单纯看直接光照明，PBR管线似乎跟上一个世代的效果差不多，真正让PBR得到超越上一个世代效果的，是其环境光照明部分，所谓的&lt;strong&gt;动态全局光照&lt;/strong&gt;的实体&lt;/p&gt;
&lt;p&gt;首先我们来重新看下，在直接光照明下，我们的渲染方程：&lt;/p&gt;
&lt;div class="math"&gt;$$L=(K_{d}f_{lambert} + K_{s}f_{cook-torrance})L_{i}(w_{i}\cdot n)$$&lt;/div&gt;
&lt;div class="math"&gt;$$L=(K_{d}\frac{diffuse}{\pi} +K_{s}\frac{DFG}{4(W_{o …&lt;/div&gt;</summary><content type="html">&lt;p&gt;在上一篇文章中，我们讨论了PBR管线的基础理论，以及实现了场景中直接光（点光源/方向光源）照明的计算，对比与Blinn-Phong模型，PBR使用了微平面理论来对现实世界建模，而在BRDF项计算中，使用了法线分布函数/几何函数/菲涅尔方程构成的BRDF方程来计算光线对某种材质最终输出光照的影响。&lt;/p&gt;
&lt;p&gt;但单纯看直接光照明，PBR管线似乎跟上一个世代的效果差不多，真正让PBR得到超越上一个世代效果的，是其环境光照明部分，所谓的&lt;strong&gt;动态全局光照&lt;/strong&gt;的实体&lt;/p&gt;
&lt;p&gt;首先我们来重新看下，在直接光照明下，我们的渲染方程：&lt;/p&gt;
&lt;div class="math"&gt;$$L=(K_{d}f_{lambert} + K_{s}f_{cook-torrance})L_{i}(w_{i}\cdot n)$$&lt;/div&gt;
&lt;div class="math"&gt;$$L=(K_{d}\frac{diffuse}{\pi} +K_{s}\frac{DFG}{4(W_{o}\cdot n)(W_{i}\cdot n)})L_{i}(w_{i}\cdot n)$$&lt;/div&gt;
&lt;p&gt;这里我们只考虑了场景中的直接光源，但除了直接光源，场景中还会有来自环境本身的光源，如下图所示&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/pbr_indirect_light.png"&gt;&lt;/p&gt;
&lt;p&gt;场景中的环境光照是指，来自环境中各个方向的光源，照射到物体，然后反射到观察者方向的照相机中，在实际中，要计算总的反射光，我们会对于场景中的每个片断点，计算以片断点中法向量n为轴的半球体中所有入射光的总和：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/pbr_indirect_lignht_semisphere.jpg"&gt;&lt;/p&gt;
&lt;p&gt;而在数学上，我们会使用半球积分来计算场景中所有环境光的总和：&lt;/p&gt;
&lt;div class="math"&gt;$$L=\int_{\Omega }(K_{d}f_{lambert} + K_{s}f_{cook-torrance})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;可以看到因为是对所有方向入射光做计算，因此我们的被积变量是&lt;span class="math"&gt;\(w_{i}\)&lt;/span&gt;，另外，如果我们将公式整理简化一下表达：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }f_{r}(p, w_{i}, w_{o})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;（这里&lt;span class="math"&gt;\(p\)&lt;/span&gt;是要计算的片段点，&lt;span class="math"&gt;\(w_{o}\)&lt;/span&gt;是出射光的方向，&lt;span class="math"&gt;\(w_{i}\)&lt;/span&gt;是入射光的方向，&lt;span class="math"&gt;\(n\)&lt;/span&gt;则是法线，&lt;span class="math"&gt;\(f_{r}\)&lt;/span&gt;则是BRDF）&lt;/p&gt;
&lt;p&gt;可以看出来，这个方程可以看做是标准&lt;a href="https://zh.wikipedia.org/wiki/%E6%B8%B2%E6%9F%93%E6%96%B9%E7%A8%8B"&gt;渲染方程&lt;/a&gt;的一个近似解&lt;/p&gt;
&lt;h3&gt;完整的PBR渲染方程&lt;/h3&gt;
&lt;p&gt;在加上了环境光之后，对于场景中某一点&lt;span class="math"&gt;\(p\)&lt;/span&gt;，想要得到最终的光照输出&lt;span class="math"&gt;\(L\)&lt;/span&gt;，完整的PBR渲染方程就变成了这样：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }f_{r}(p, w_{i}, w_{o})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;可以看到要真正计算完整的光照，外面是一个半球积分，然而，这个半球积分并没有解析解，而计算机是离散的，所以我们通常会采用某种&lt;strong&gt;采样&lt;/strong&gt;的方法，来近似计算积分的值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;steps&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;P&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;Wo&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;...;&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;dW&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;steps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;steps&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;Wi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getNextIncomingLightDir&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;sum&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;Fr&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Wi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Wo&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;p&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Wi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Wi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dW&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;为了计算这个积分的近似值，我们再将积分函数展开：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }(K_{d}f_{lambert} + K_{s}f_{cook-torrance})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;因为积分中漫反射跟高光部分是加法，我们可以对积分进行拆解：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }(K_{d}f_{lambert})L_{i}(w_{i}\cdot n)dw_{i} + \int_{\Omega }(K_{s}f_{cook-torrance})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;于是我们将积分拆解成了漫反射部分跟高光部分，我们拆开来，再将公式展开：&lt;/p&gt;
&lt;p&gt;则漫反射部分为：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }(K_{d}\frac{diffuse}{\pi})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;高光部分为：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }(K_{s}\frac{DFG}{4(W_{o}\cdot n)(W_{i}\cdot n)})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;以上是渲染的方程，而在具体的工程实现上，我们对场景中环境光源的模拟，则使用所谓的&lt;strong&gt;Imaged Based Lighting(IBL)&lt;/strong&gt;，即为基于图片的光照，通过在场景中添加环境贴图，也就是cubemap，作为环境中的光源的采样来源，然后再来照明物体&lt;/p&gt;
&lt;p&gt;接下来我们再分别对漫反射和高光部分的光照分别求解&lt;/p&gt;
&lt;h3&gt;漫反射环境光照&lt;/h3&gt;
&lt;p&gt;首先，对于场景中的某一点，漫反射部分光照的积分公式为：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }(K_{d}\frac{diffuse}{\pi})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;我们先把常量部分拆出来：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=K_{d}\frac{diffuse}{\pi}\int_{\Omega }L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;因为计算机是离散的，要直接计算这个积分是不可能的，因此，我们通过连续采样，然后计算平均值的方法，来近似的计算这个积分的值，我们参考&lt;a href="http://www.codinglabs.net/article_physically_based_rendering.aspx"&gt;这里&lt;/a&gt;的推导：&lt;/p&gt;
&lt;p&gt;首先，我们将半球积分，转换成为普通的半球二重积分：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=K_{d}\frac{diffuse}{\pi}\int_{-\pi}^{\pi}\int_{0}^{\frac{\pi}{2}}L_{i}cos(\theta _{i})sin(\theta _{i})d\phi _{i}$$&lt;/div&gt;
&lt;p&gt;其中&lt;span class="math"&gt;\(\theta _{i}\)&lt;/span&gt;则为光线方向跟半球法线方向的夹角&lt;/p&gt;
&lt;p&gt;然后，对于积分，计算机中常见的计算方式是，使用&lt;a href="https://en.wikipedia.org/wiki/Monte_Carlo_method"&gt;蒙特卡洛方法&lt;/a&gt;来近似计算，令我们在球坐标系下的两个方向上采样数为&lt;span class="math"&gt;\(N_{1}\)&lt;/span&gt;和&lt;span class="math"&gt;\(N_{2}\)&lt;/span&gt;，代入如下：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=K_{d}\frac{diffuse}{\pi}\frac{2\pi}{N_{1}}\frac{\pi}{2N_{2}} L_{i}cos(\theta _{i})sin(\theta _{i})$$&lt;/div&gt;
&lt;p&gt;
消去多余项之后则如下
&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=K_{d}\frac{\pi diffuse}{N_{1}N_{2}} L_{i}cos(\theta _{i})sin(\theta _{i})$$&lt;/div&gt;
&lt;p&gt;
我们稍微简化一下表达，令&lt;span class="math"&gt;\(c=diffuse\)&lt;/span&gt;：
&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=K_{d}\frac{\pi c}{N_{1}N_{2}} L_{i}cos(\theta _{i})sin(\theta _{i})$$&lt;/div&gt;
&lt;p&gt;得到了这个公式之后，我们实现就很明确了，因为想要计算的是环境的漫反射光照，因此：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;span class="math"&gt;\(L_{i}\)&lt;/span&gt; 可以采样为环境中天空盒纹理中的颜色作为光照来源，这就是字面意义的&lt;strong&gt;基于图片的光照&lt;/strong&gt;，对于场景中的一点我们都通过积分计算得到了来自半球上各个方向的光照，对于PBR管线来说，需要在线性空间计算光照，因此天空盒的纹理必须是HDR图片，对于GLES来说，就是GL_RGB16F的颜色格式，否则最终渲染的结果，对比度会明显不够&lt;/li&gt;
&lt;li&gt;对于这个公式，我们可以在当前片断方向周围进行连续采样来计算积分，采样次数越多，积分结果越准确&lt;/li&gt;
&lt;li&gt;最终，我们可以通过对天空盒纹理上的每个片断进行各个方向上的连续采样，将得到的结果存储在另外一张cubemap纹理中，最终直接采样这张纹理即可作为环境中的漫反射光照了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;上面计算的代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WorldPos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;irradiance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// tangent space calculation from origin point&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cross&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;up&lt;/span&gt;            &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cross&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;sampleDelta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.025&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;nrSamples&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;phi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;phi&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;2.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;PI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;phi&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;sampleDelta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;PI&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;theta&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;sampleDelta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// spherical to cartesian (in tangent space)&lt;/span&gt;
        &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;tangentSample&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;  &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
        &lt;span class="c1"&gt;// tangent space to world&lt;/span&gt;
        &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;sampleVec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tangentSample&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;right&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tangentSample&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;tangentSample&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;irradiance&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;environmentMap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sampleVec&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;theta&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;nrSamples&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;irradiance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;irradiance&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nrSamples&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

&lt;span class="n"&gt;FragColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;irradiance&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;将上面预采样的结果存储在另外一张cubemap纹理中，而在主shader中，我们对场景漫反射的采样只需要这样子计算就可以了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;irradiance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;irradianceMap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;diffuse&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;irradiance&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;albedo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;预计算之后，我们得到了的纹理大概是这个样子的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ibl_irradiance.png"&gt;&lt;/p&gt;
&lt;p&gt;做了积分之后，看出来图片跟类似做了卷积之后的结果有点类似，直接对右边图片采样，我们就可以得到对于场景中一点得到各个方向上漫反射的光照结果了，下图就是加了漫反射之后，在金属度为1.0，不同粗糙度下的渲染结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/irradiance_ibl_render_result.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看到，因为有了漫反射光照，我们渲染的结果比原来稍微亮了一些&lt;/p&gt;
&lt;p&gt;另外，除了直接计算，我们也可以利用&lt;a href="https://github.com/dariomanesku/cmft"&gt;cmft&lt;/a&gt;来生成这张预计算贴图：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cmft --input &lt;span class="s2"&gt;&amp;quot;xx.hdr&amp;quot;&lt;/span&gt;           &lt;span class="se"&gt;\&lt;/span&gt;
            --filter irradiance               &lt;span class="se"&gt;\&lt;/span&gt;
            --srcFaceSize &lt;span class="m"&gt;0&lt;/span&gt;                   &lt;span class="se"&gt;\&lt;/span&gt;
            --dstFaceSize &lt;span class="m"&gt;256&lt;/span&gt;                   &lt;span class="se"&gt;\&lt;/span&gt;
            --outputNum &lt;span class="m"&gt;1&lt;/span&gt;                     &lt;span class="se"&gt;\&lt;/span&gt;
            --output0 &lt;span class="s2"&gt;&amp;quot;xx_irradiance&amp;quot;&lt;/span&gt;         &lt;span class="se"&gt;\&lt;/span&gt;
            --output0params dds,bgra8,cubemap
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里最终会生成一张DDS格式的纹理，不过，在Android直接使用会有问题，这里会在文章后面说下这里的坑&lt;/p&gt;
&lt;h3&gt;高光环境光照&lt;/h3&gt;
&lt;p&gt;接下来我们再来继续实现高光部分，首先，我们再来看下高光部分的渲染方程为：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }(K_{s}\frac{DFG}{4(W_{o}\cdot n)(W_{i}\cdot n)})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;我们稍微简化下表达，把BRDF部分收回去：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }f_{r}(p, w_{i}, w_{o})L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;可以看出来高光部分的积分要比漫反射部分复杂得多，无论是直接求解或者是直接应用蒙特卡洛积分计算都会变得相当复杂，而在很多游戏引擎中，为了求解，都会对这个积分进行拆解，变成两个积分的乘积来近似，这种方法叫做&lt;strong&gt;Split Sum Approximation&lt;/strong&gt;，拆解之后，我们的积分变成了这样子：&lt;/p&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }L_{i}(w_{i}\cdot n)dw_{i} * \int_{\Omega }f_{r}(p, w_{i}, w_{o})(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;因此，我们的高光部分积分，就分成了两个部分&lt;/p&gt;
&lt;h4&gt;预过滤环境贴图（Pre-filtered environment map）&lt;/h4&gt;
&lt;div class="math"&gt;$$L(p, w_{o})=\int_{\Omega }L_{i}(w_{i}\cdot n)dw_{i}$$&lt;/div&gt;
&lt;p&gt;类似针对漫反射光照的处理一样，对这个积分的计算，我们也采用蒙特卡洛积分来近似计算，但对于高光反射，我们会针对不同的粗糙度，生成不同大小的预计算纹理贴图，用来作为不同粗糙度下高光的环境光反射，这同样符合物理结果，粗糙度越高，对于高光反射越弱。而对于GLES来说，最合理的做法就是把不同粗糙度下的预计算结果存储在不同级别的mipMap level中，在使用的时候，再根据材质粗糙度插值来选取对应mipmap level的纹理：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ibl_prefilter_map.png"&gt;&lt;/p&gt;
&lt;p&gt;而在计算处理上，虽然我们也可以直接类似漫反射光照那样子，直接在半球空间内均匀采样然后再求值平均，但对于高光反射来说，由于表面粗糙度的影响，不同粗糙度的表面对光线的反射输出也不同&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ibl_specular_lobe.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看出来粗糙度越高的表面，反射的光线越分散，结合PBR的微表面模型，可以看出来对于某个片断点，高光反射的光线分布在半程向量的周围，因此我们可以结合粗糙度，以及法线分布函数，让计算时候的采样向量收敛在一个区间内，这就是&lt;strong&gt;重要性采样&lt;/strong&gt;，结合蒙特卡洛方法的公式如下:&lt;/p&gt;
&lt;div class="math"&gt;$$\int_{a}^{b}f(x)dx=\frac{1}{N}\sum_{i=0}^{N-1}\frac{f(x)}{pdf(x)}$$&lt;/div&gt;
&lt;p&gt;其中&lt;span class="math"&gt;\(pdf(x)\)&lt;/span&gt;为概率密度函数&lt;/p&gt;
&lt;p&gt;因此，在得到采样点之后，我们的进行重要性采样计算代码为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;ImportanceSampleGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;Xi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;phi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;2.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Xi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;cosTheta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;Xi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;Xi&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;sinTheta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sqrt&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cosTheta&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cosTheta&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="c1"&gt;// from spherical coordinates to cartesian coordinates - halfway vector&lt;/span&gt;
    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cos&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;sinTheta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sin&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;phi&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;sinTheta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cosTheta&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="c1"&gt;// from tangent-space H vector to world-space sample vector&lt;/span&gt;
    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;up&lt;/span&gt;          &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;abs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="mf"&gt;0.999&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;tangent&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cross&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;up&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;bitangent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cross&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tangent&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;sampleVec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;tangent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;bitangent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;sampleVec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里我们先得到的采样向量，然后计算出对应世界坐标系下的向量作为半程向量返回&lt;/p&gt;
&lt;p&gt;这里我们还需要生成一个随机向量Xi，而对于蒙特卡洛积分来说，我们需要一种叫做&lt;strong&gt;低差异序列&lt;/strong&gt;的特殊随机数：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ibl_low_discrepancy_sequence.png"&gt;&lt;/p&gt;
&lt;p&gt;而在这里我们则使用所谓的Hammersley序列来生成，代码如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="c1"&gt;// http://holger.dammertz.org/stuff/notes_HammersleyOnHemisphere.html&lt;/span&gt;
&lt;span class="c1"&gt;// efficient VanDerCorpus calculation.&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;RadicalInverse_VdC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;16&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x55555555&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xAAAAAAAA&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x33333333&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xCCCCCCCC&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x0F0F0F0F&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xF0F0F0F0&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0x00FF00FF&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&amp;lt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;|&lt;/span&gt; &lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="mh"&gt;0xFF00FF00&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
     &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bits&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="mf"&gt;2.3283064365386963e-10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// / 0x100000000&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="k"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;Hammersley&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;RadicalInverse_VdC&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在得到了采样向量之后，我们就可以最终计算出预计算的结果了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;WorldPos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// make the simplyfying assumption that V equals R equals the normal&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;SAMPLE_COUNT&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;prefilteredColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;totalWeight&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;uint&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mo"&gt;0&lt;/span&gt;&lt;span class="n"&gt;u&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;SAMPLE_COUNT&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// generates a sample vector that&amp;#39;s biased towards the preferred alignment direction (importance sampling).&lt;/span&gt;
    &lt;span class="k"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;Xi&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Hammersley&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;SAMPLE_COUNT&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ImportanceSampleGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Xi&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NdotL&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;// sample from the environment&amp;#39;s mip level based on roughness/pdf&lt;/span&gt;
        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DistributionGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;HdotV&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;D&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;NdotH&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;4.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;HdotV&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;0.0001&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;resolution&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;512.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// resolution of source cubemap (per face)&lt;/span&gt;
        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;saTexel&lt;/span&gt;  &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;4.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;$&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="n"&gt;RadianceMipmapLevel&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;}&lt;/span&gt;&lt;span class="mf"&gt;.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;resolution&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;resolution&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;saSample&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;SAMPLE_COUNT&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pdf&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;0.0001&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;mipLevel&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="o"&gt;?&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="mf"&gt;0.5&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;log2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;saSample&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;saTexel&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;prefilteredColor&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;environmentMap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mipLevel&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;totalWeight&lt;/span&gt;      &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="n"&gt;prefilteredColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;prefilteredColor&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;totalWeight&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;FragColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;prefilteredColor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看到，在计算的时候，我们针对采样的半程向量，对其反射光线以及视角方向进行了N=V=R的假设，这个是因为在预计算的场景下，我们没有办法计算出真实的视角方向以及法线向量，只能进行一定的假设了，然后，按照反射模型倒推出了采样的光线方向，然后再对天空盒纹理采样。&lt;/p&gt;
&lt;p&gt;另外，注意到对于每次采样，我们都乘以了NdotL作为权重，因为在NdotL&amp;lt;0的情况下，这个时候这个光线是对高光没有贡献的&lt;/p&gt;
&lt;p&gt;（这里数学推导过于复杂，我这里也没完全搞懂，有兴趣也可以继续看看这篇&lt;a href="https://zhuanlan.zhihu.com/p/34741174"&gt;文章&lt;/a&gt;了解下）&lt;/p&gt;
&lt;p&gt;而在采样的时候，对天空盒纹理的不同miplevel进行了采样，由于这段代码来自&lt;a href="https://learnopengl.com/PBR/IBL/Specular-IBL"&gt;这里&lt;/a&gt;，不过在Android上，我发现有没有按照粗糙度对天空盒mipmap level采样似乎没有太大差别，这里原因还没有深究&lt;/p&gt;
&lt;p&gt;另外，跟漫反射部分一样，这里的贴图，我们同样可以利用cmft来生成：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;cmft --input &lt;span class="s2"&gt;&amp;quot;xxx.hdr&amp;quot;&lt;/span&gt;           &lt;span class="se"&gt;\&lt;/span&gt;
              ::Filter options                  &lt;span class="se"&gt;\&lt;/span&gt;
              --filter radiance                 &lt;span class="se"&gt;\&lt;/span&gt;
              --srcFaceSize &lt;span class="m"&gt;256&lt;/span&gt;                 &lt;span class="se"&gt;\&lt;/span&gt;
              --excludeBase &lt;span class="nb"&gt;false&lt;/span&gt;               &lt;span class="se"&gt;\&lt;/span&gt;
              --mipCount &lt;span class="m"&gt;7&lt;/span&gt;                      &lt;span class="se"&gt;\&lt;/span&gt;
              --glossScale &lt;span class="m"&gt;10&lt;/span&gt;                   &lt;span class="se"&gt;\&lt;/span&gt;
              --glossBias &lt;span class="m"&gt;3&lt;/span&gt;                     &lt;span class="se"&gt;\&lt;/span&gt;
              --lightingModel blinnbrdf         &lt;span class="se"&gt;\&lt;/span&gt;
              --edgeFixup none                  &lt;span class="se"&gt;\&lt;/span&gt;
              --dstFaceSize &lt;span class="m"&gt;256&lt;/span&gt;                 &lt;span class="se"&gt;\&lt;/span&gt;
              ::Processing devices              &lt;span class="se"&gt;\&lt;/span&gt;
              --numCpuProcessingThreads &lt;span class="m"&gt;4&lt;/span&gt;       &lt;span class="se"&gt;\&lt;/span&gt;
              --useOpenCL &lt;span class="nb"&gt;true&lt;/span&gt;                  &lt;span class="se"&gt;\&lt;/span&gt;
              --clVendor anyGpuVendor           &lt;span class="se"&gt;\&lt;/span&gt;
              --deviceType gpu                  &lt;span class="se"&gt;\&lt;/span&gt;
              --deviceIndex &lt;span class="m"&gt;0&lt;/span&gt;                   &lt;span class="se"&gt;\&lt;/span&gt;
              ::Aditional operations            &lt;span class="se"&gt;\&lt;/span&gt;
              --inputGammaNumerator &lt;span class="m"&gt;2&lt;/span&gt;.2         &lt;span class="se"&gt;\&lt;/span&gt;
              --inputGammaDenominator &lt;span class="m"&gt;1&lt;/span&gt;.0       &lt;span class="se"&gt;\&lt;/span&gt;
              --outputGammaNumerator &lt;span class="m"&gt;1&lt;/span&gt;.0        &lt;span class="se"&gt;\&lt;/span&gt;
              --outputGammaDenominator &lt;span class="m"&gt;2&lt;/span&gt;.2      &lt;span class="se"&gt;\&lt;/span&gt;
              --generateMipChain &lt;span class="nb"&gt;false&lt;/span&gt;          &lt;span class="se"&gt;\&lt;/span&gt;
              ::Output                          &lt;span class="se"&gt;\&lt;/span&gt;
              --outputNum &lt;span class="m"&gt;1&lt;/span&gt;                     &lt;span class="se"&gt;\&lt;/span&gt;
              --output0 &lt;span class="s2"&gt;&amp;quot;xxx&amp;quot;&lt;/span&gt;       &lt;span class="se"&gt;\&lt;/span&gt;
              --output0params dds,bgra8,cubemap &lt;span class="se"&gt;\&lt;/span&gt;
              --output1 &lt;span class="s2"&gt;&amp;quot;xxx_preview&amp;quot;&lt;/span&gt;       &lt;span class="se"&gt;\&lt;/span&gt;
              --output1params tga,rgba8,cubemap
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;环境光BRDF（Environment BRDF）&lt;/h4&gt;
&lt;p&gt;而对于积分的另外一部分，则为包含了BRDF部分的高光环境计算，这里我们同样可以类似上面那样，进行重要性采样，然后计算出一个预先采样的纹理，这这篇&lt;a href="https://learnopengl.com/PBR/IBL/Specular-IBL"&gt;文章&lt;/a&gt;中有比较详细的描述，经过对积分的公式变换之后，我们将第二部分的积分公式变换成这个形式：&lt;/p&gt;
&lt;div class="math"&gt;$$F_{0}\int_{\Omega}f_{r}(p, w_{i}, w_{o})(1-(1-w_{o}\cdot h)^{5})w_{i}\cdot n dw_{i} + \int_{\Omega}f_{r}(p, w_{i}, w_{o})(1-w_{o} \cdot h)^{5}w_{i} \cdot n dw_{i}$$&lt;/div&gt;
&lt;p&gt;这个公式可以表达成这个形式：&lt;/p&gt;
&lt;div class="math"&gt;$$F_{0} * Scale + Bias$$&lt;/div&gt;
&lt;p&gt;于是我们可以预计算出&lt;span class="math"&gt;\(Scale\)&lt;/span&gt;跟&lt;span class="math"&gt;\(Bias\)&lt;/span&gt;的值，把结果存储在一张纹理上，计算出来的结果大概是这样子的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ibl_brdf_lut.png"&gt;&lt;/p&gt;
&lt;p&gt;这是一张LUT纹理，使用NdotV以及roughness作为纹理坐标，采样就可以得到上面的计算结果，然后配合上面生成高光反射贴图，就可以得到高光部分的反射：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;textureLod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radianceMap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;MAX_RADIANCE_LOD&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec2&lt;/span&gt; &lt;span class="n"&gt;brdf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;texture&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;envBrdfMap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;)).&lt;/span&gt;&lt;span class="n"&gt;rg&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;specular&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;brdf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;brdf&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但在移动平台上，更为经济的做法是，对这个积分本身做数值拟合，在&lt;a href="https://zhuanlan.zhihu.com/p/53086060"&gt;PBR白皮书&lt;/a&gt;，有看到介绍在使命召唤——黑色行动2中便使用了这个做法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;EnvDFGLazarov&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;specularColor&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;gloss&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;ndotv&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//# [ Lazarov 2013, &amp;quot;Getting More Physical in Call of Duty: Black Ops II&amp;quot; ]&lt;/span&gt;
    &lt;span class="c1"&gt;//# Adaptation to fit our G term.&lt;/span&gt;
    &lt;span class="k"&gt;vec4&lt;/span&gt; &lt;span class="n"&gt;p0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mf"&gt;0.5745&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.548&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.02397&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.301&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;vec4&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec4&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mf"&gt;0.5753&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.2511&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;0.02066&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.4755&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;vec4&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gloss&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;p0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;p1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;bias&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clamp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;exp2&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mf"&gt;7.672&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ndotv&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;z&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;delta&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clamp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="n"&gt;t&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;w&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;delta&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;bias&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;bias&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="n"&gt;clamp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt; &lt;span class="mf"&gt;50.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;specularColor&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;specularColor&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;scale&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;bias&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中specularColor则为F0，而具体的推导可以在这篇&lt;a href="https://zhuanlan.zhihu.com/p/41150563"&gt;文章&lt;/a&gt;中得到答案，其实就是在Mathematica中进行不停的拟合得到的结果，但对于手机来说，省去了一张纹理的消耗，是一个不错的优化&lt;/p&gt;
&lt;p&gt;使用了这个方法来计算解析值之后，高光部分的反射结果就改成这样子计算出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;textureLod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;radianceMap&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;R&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;MAX_RADIANCE_LOD&lt;/span&gt;&lt;span class="p"&gt;).&lt;/span&gt;&lt;span class="n"&gt;rgb&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;envBrdf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EnvDFGLazarov&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;F0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metallic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;specular&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;F&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;envBrdf&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;组合渲染输出&lt;/h3&gt;
&lt;p&gt;在得到高光以及漫反射部分的渲染结果之后，组合最终输出就很简单了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;ambient&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;diffuse&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;specular&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ao&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ambient&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;Lo&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样，因为显示到普通屏幕上，我们需要对输出进行色调映射跟Gamma校正：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// HDR tonemapping&lt;/span&gt;
&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="c1"&gt;// gamma correct&lt;/span&gt;
&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下面便是在加了高光跟漫反射环境光之后，在金属度为1，不同粗糙度下的渲染结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/radiance_ibl_render_result.jpg"&gt;&lt;/p&gt;
&lt;p&gt;可以看出来，在加了高光反射之后，我们的渲染结果质量有了很明显的提升&lt;/p&gt;
&lt;h3&gt;带上纹理贴图的输出&lt;/h3&gt;
&lt;p&gt;在PBR的管线下，设计师可以针对&lt;strong&gt;金属度&lt;/strong&gt;以及&lt;strong&gt;粗糙度&lt;/strong&gt;分别建模贴图，从而给模型提供像素级别精度的参数调整，结合漫反射贴图以及法线贴图，我们就可以得出非常漂亮的渲染结果了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ibl_model_render_result.png"&gt;&lt;/p&gt;
&lt;h3&gt;Notes&lt;/h3&gt;
&lt;p&gt;最后，我们来聊聊实际实现的时候，遇到一些问题：&lt;/p&gt;
&lt;h4&gt;DDS格式的问题&lt;/h4&gt;
&lt;p&gt;cmft工具导出来的预计算贴图格式，一般是DDS，而在Android上，是没有办法直接通过原生接口解码DDS格式的，另外，cmft中导出的DDS格式也没办法指定支持rgba16这种颜色格式，会导致渲染出来对比度过低，所以，要做预计算贴图，靠谱的方法还是自己写个工具来计算&lt;/p&gt;
&lt;h4&gt;HDR格式在Android的支持&lt;/h4&gt;
&lt;p&gt;HDR格式的图片，同样，在Android系统中原生接口中是没办法直接解码的，但png有支持到64位的颜色格式，所以我们可以先将hdr格式图片转成png再来做贴图的预计算&lt;/p&gt;
&lt;p&gt;本文可能有诸多错漏，作为一名图形学小白，数学功底也比较有限，各位看客求轻喷&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/53086060"&gt;https://zhuanlan.zhihu.com/p/53086060&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learnopengl.com/PBR/IBL/Diffuse-irradiance"&gt;https://learnopengl.com/PBR/IBL/Diffuse-irradiance&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://learnopengl.com/PBR/IBL/Specular-IBL"&gt;https://learnopengl.com/PBR/IBL/Specular-IBL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/34741174"&gt;https://zhuanlan.zhihu.com/p/34741174&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/41150563"&gt;https://zhuanlan.zhihu.com/p/41150563&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://zhuanlan.zhihu.com/p/21489591"&gt;https://zhuanlan.zhihu.com/p/21489591&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (true) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content></entry><entry><title>尝试在Android中实现PBR管线——基本原理以及直接光照明</title><link href="http://ragnraok.github.io/try_android_implement_pbr_thery_direct_light.html" rel="alternate"></link><published>2019-08-18T00:00:00+08:00</published><updated>2019-08-18T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2019-08-18:/try_android_implement_pbr_thery_direct_light.html</id><summary type="html">&lt;p&gt;从本个世代起，基于物理的渲染（Physically Based Rendering，简称PBR）基本上就成为了事实上当下3A大作的渲染标准，自从迪士尼在在SIGGRAPH 2012上提出的著名的“迪士尼原则的BRDF”以及基于金属工作流来实现的方案，由于高度的易用性，美术设计师可以根据现实物理的参数来构建表面材质，可以实现惊人的显示效果，目前已经被广泛的在业界中使用&lt;/p&gt;
&lt;p&gt;这篇文章将会尝试在Android中基于Kotlin来实现PBR管线，在正式开始代码实现之前，我们先来讨论下PBR管线的基础理论。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Before PBR&lt;/h2&gt;
&lt;p&gt;首先我们来看看，在PBR出现之前，传统的Blinn-Phong光照是怎么做的，我们先来看看渲染方程：&lt;/p&gt;
&lt;!-- ![](static/images/Blinn_Phong.png) --&gt;

&lt;div class="math"&gt;$$L=Diffuse\ast N\cdot L+Specular+(N\cdot L)^{shiness}$$&lt;/div&gt;
&lt;p&gt;我们可以看到，光照颜色的输出，主要有两部分构成，&lt;strong&gt;漫反射&lt;/strong&gt;项以及&lt;strong&gt;高光项&lt;/strong&gt;，在渲染方程中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Diffuse\)&lt;/span&gt;是漫反射颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Specular\)&lt;/span&gt;是高光颜色，或者叫做镜面反射的颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(N\cdot L …&lt;/span&gt;&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;从本个世代起，基于物理的渲染（Physically Based Rendering，简称PBR）基本上就成为了事实上当下3A大作的渲染标准，自从迪士尼在在SIGGRAPH 2012上提出的著名的“迪士尼原则的BRDF”以及基于金属工作流来实现的方案，由于高度的易用性，美术设计师可以根据现实物理的参数来构建表面材质，可以实现惊人的显示效果，目前已经被广泛的在业界中使用&lt;/p&gt;
&lt;p&gt;这篇文章将会尝试在Android中基于Kotlin来实现PBR管线，在正式开始代码实现之前，我们先来讨论下PBR管线的基础理论。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;Before PBR&lt;/h2&gt;
&lt;p&gt;首先我们来看看，在PBR出现之前，传统的Blinn-Phong光照是怎么做的，我们先来看看渲染方程：&lt;/p&gt;
&lt;!-- ![](static/images/Blinn_Phong.png) --&gt;

&lt;div class="math"&gt;$$L=Diffuse\ast N\cdot L+Specular+(N\cdot L)^{shiness}$$&lt;/div&gt;
&lt;p&gt;我们可以看到，光照颜色的输出，主要有两部分构成，&lt;strong&gt;漫反射&lt;/strong&gt;项以及&lt;strong&gt;高光项&lt;/strong&gt;，在渲染方程中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Diffuse\)&lt;/span&gt;是漫反射颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(Specular\)&lt;/span&gt;是高光颜色，或者叫做镜面反射的颜色&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(N\cdot L\)&lt;/span&gt; 是表面法向量跟光线方向向量的点乘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(N\cdot H\)&lt;/span&gt; 是表面法向量跟半程向量（光线方向向量跟视角向量的中间向量）的点乘&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;span class="math"&gt;\(shiness\)&lt;/span&gt;是高光度的反光度参数，值越大，高光点越集中&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;这个是经典的Blinn-Phong光照模型的，除了这个基本公式以外，后续也有针对这个模型一些改进项，使其更加符合物理上的直觉效果&lt;/p&gt;
&lt;p&gt;这个光照模型并不复杂，但终究并非基于真实的物理参数进行材质的构建，实际渲染的时候往往得不到令人信服的效果。&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;PBR基础理论&lt;/h2&gt;
&lt;p&gt;接下来，我们再来介绍PBR的基础理论，以下内容以及图片参考自：&lt;a href="[https://learnopengl-cn.github.io/07%20PBR/01%20Theory](https://learnopengl-cn.github.io/07%20PBR/01%20Theory)"&gt;PBR理论&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;微平面模型&lt;/h3&gt;
&lt;p&gt;所有的PBR理论都基于一种叫做微平面模型的理论，这个理论认为在微观尺度上，所有物体的表面都可以使用所谓的微平面（Microfacets）的细小镜面来进行描述，根据表面粗糙度的不同，这些微平面的排列可以相当不一致：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/microfacets.png"&gt;&lt;/p&gt;
&lt;p&gt;因此，这些微平面的排列则极大的影响了光线的反射：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/microfacets_light_rays.png"&gt;&lt;/p&gt;
&lt;p&gt;因此，粗糙度越高的表面，表面光线反射越分散，反之则越集中：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ndf.png"&gt;&lt;/p&gt;
&lt;p&gt;在实际的PBR实现中，粗糙度（Roughness）是用来调整PBR效果的一个重要参数之一&lt;/p&gt;
&lt;h3&gt;能量守恒&lt;/h3&gt;
&lt;p&gt;在PBR中，能量守恒定律认为，出射的光线能量，永远不能超过入射光线的能量。在微平面模型中，对于一束光进入到进入到物体表面之后，我们分成了几个部分：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;折射部分，指的是被吸收到物体表面的那部分光线能量，具体表现出来就是物体的漫反射（Diffuse）&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;反射部分，指的是光线反射出来离开物体表面的那部分光照，具体指的就是镜面高光（Specular）&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于非金属物质来说，光线射进物体都会产生折射跟反射部分，而对于金属物质来说，微平面理论认为金属表面不会显示出漫反射部分，所有光线都会被处理成镜面高光&lt;/p&gt;
&lt;p&gt;而能量守恒的要求，则是要求漫反射+高光部分占比加起来为1，实际实现中，我们往往先算出高光部分占比，然后在算出漫反射部分占比：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;kS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;calculateSpecularComponent&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// 反射/镜面 部分&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;ks&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// 折射/漫反射 部分&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;对比传统的Blinn-Phong模型，由于起没有考虑能量守恒，所以往往很难得出令人信服的效果&lt;/p&gt;
&lt;h3&gt;基于物理的BRDF&lt;/h3&gt;
&lt;p&gt;BRDF（Bidirectional Reflectance Distribution Function），即为双向反射分布函数，是整个PBR管线中最为重要的函数之一，可以用来求出每条光线对了一个给定材质属性的表面上，最终反射出来的光线的贡献程度。类比Blinn-Phong模型来说，我们拿漫反射项颜色乘以NdotL，其实也是一种BRDF计算方式，只是没有基于物理理论来建模，所以没有办法得出令人信服的效果。&lt;/p&gt;
&lt;p&gt;类似Blinn-Phong模型，PBR的BRDF也是接受入射光方向Wi，反射光方向Wo，以及一个跟微平面理论相关的物理参数粗糙度（Roughness），实际实现中，最为常用的则是被称为Cook-Torrance的BRDF模型，同时兼具漫反射以及镜面反射两部分：&lt;/p&gt;
&lt;div class="math"&gt;$$L=K_{d}f_{lambert} + K_{s}f_{cook-torrance}$$&lt;/div&gt;
&lt;ul&gt;
&lt;li&gt;其中Kd表示漫反射光照的能量占比，Ks则表示镜面反射的能量占比，两项加起来为1，而对于漫反射中的Lambert项，我们经常用这个公式计算：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$f_{lambert}=\frac{diffuse}{\pi}$$&lt;/div&gt;
&lt;p&gt;我们将漫反射颜色除以PI，作为BRDF公式的漫反射部分。这部分并没有什么特别的，实际上在Blinn-Phong模型的改进版本中，也有将漫反射颜色除以PI的做法，用于得到更加真实的效果&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;而BRDF公式的镜面高光部分则比较复杂：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="math"&gt;$$f_{cook-torrance}=\frac{DFG}{4(W_{o}\cdot n)(W_{i}\cdot n)}$$&lt;/div&gt;
&lt;p&gt;这里包含了三个主要的参数，D/F/G分别代表三种不同种类的函数，分别用来模拟反射的不同部分的特性，分母则为一个配平参数用来作为标准化因子。D/F/G三个函数则分别为：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;法线分布函数（Normal Distribution Function）：用于估算在收到表面粗糙度的影响下，取向方向与半程向量一致的微平面向量&lt;/li&gt;
&lt;li&gt;几何函数（Geometry Function）：用于描述微平面自成阴影的的函数，在表面粗糙度比较大的时候，平面上的微表面可能挡住了其他微表面的光线&lt;/li&gt;
&lt;li&gt;菲涅尔方程（Fresnel Rquation）：用于描述光线在不同的入射角度下表面反射光线所占的比率&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;以上每一种函数都描述了对应不同的物理现象，而实际渲染中，我们都会采用某种近似的函数，接下来我们来说下这几种近似函数的公式：&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;BRDF近似项计算&lt;/h3&gt;
&lt;p&gt;这里BRDF近似项的选择，同样参照自：&lt;a href="[https://learnopengl-cn.github.io/07%20PBR/01%20Theory](https://learnopengl-cn.github.io/07%20PBR/01%20Theory)"&gt;PBR理论&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;法线分布函数（Normal Distribution Function）的近似&lt;/h4&gt;
&lt;p&gt;法线分布函数从统计学的角度，描述了微平面模型对半程向量H的扰动程度，如果说给定H向量，NDF返回0.35，我们就认为整个平面中有35%的H向量与给定的向量一致，NDF的返回受表面粗糙度的影响，不同NDF的返回对镜面高光的区域影响很大：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/ndf.png"&gt;&lt;/p&gt;
&lt;p&gt;可以看到到NDF返回值越小，镜面高光区域越小&lt;/p&gt;
&lt;p&gt;实际渲染中，我们所使用的NDF方程为Trowbridge-Reitz GGX分布：&lt;/p&gt;
&lt;div class="math"&gt;$$NDF(n,h,a)=\frac{a^{2}}{\pi((n\cdot h)^{2}(a^{2}-1)+1)^{2}}$$&lt;/div&gt;
&lt;p&gt;这里参数a取为粗糙度的平方&lt;/p&gt;
&lt;p&gt;使用glsl的实现则如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;DistributionGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotH&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotH2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NdotH&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;NdotH&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;nom&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;a2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NdotH2&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;a2&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;denom&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;saturateMediump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nom&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;几何函数（Geometry Function）的近似&lt;/h4&gt;
&lt;p&gt;几何函数描述了微平面中互相被遮蔽的比率，跟法线分布函数类似，都是从统计学的角度描述了微平面的属性：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/geometry_shadowing.png"&gt;&lt;/p&gt;
&lt;p&gt;这里我们使用的几何函数为Schlick-GGX近似：&lt;/p&gt;
&lt;div class="math"&gt;$$G(n,v,k)=\frac{n\cdot v}{(n\cdot v)(1-k)+k)}$$&lt;/div&gt;
&lt;p&gt;其中参数k在计算直接光的时候为：&lt;/p&gt;
&lt;div class="math"&gt;$$k=\frac{(a+1)^{2}}{8}$$&lt;/div&gt;
&lt;p&gt;这里参数a同样也是取为粗糙度的平方&lt;/p&gt;
&lt;p&gt;而在实际渲染中，我们还将需要光线的方向向量来将两者纳入其中：&lt;/p&gt;
&lt;div class="math"&gt;$$G_{smith}=G(n,v,k)G(n,l,k)$$&lt;/div&gt;
&lt;p&gt;通过以上公式，在不同的粗糙度下可以得到如下的效果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/geometry.png"&gt;&lt;/p&gt;
&lt;p&gt;以上方程使用glsl的实现如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;GeometrySchlickGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotV&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;r&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;roughness&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;r&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="mf"&gt;8.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;nom&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NdotV&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NdotV&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;k&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;saturateMediump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;nom&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;denom&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// ----------------------------------------------------------------------------&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;GeometrySmith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotV&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;ggx2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GeometrySchlickGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NdotV&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;ggx1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GeometrySchlickGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NdotL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;saturateMediump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ggx1&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;ggx2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br/&gt;&lt;/p&gt;
&lt;h4&gt;菲涅尔方程（Fresnel Rquation）的近似&lt;/h4&gt;
&lt;p&gt;菲涅尔方程描述了光线被反射部分的比率，因而会受到观察方向的影响，结合能量守恒，我们可以得出剩下的漫反射的比率。而要计算出菲涅尔方程，我们需要一个基础反射率（F0）的参数，描述的是在表面的掠射角方向望过去（此时表面法线跟视线方向成90度），不同材料的表面反射率都不太一样：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/brdf_f_f0.jpg"&gt;&lt;/p&gt;
&lt;p&gt;我们这里取0.04作为近似的基础反射率，另外，这里我们还需要额外引入一个叫做金属度（Metallic）的参数，结合F0，一般我们这样子来计算出材质的真实F0：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;F0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;0.04&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;F0&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;mix&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;F0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;albedo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;metallic&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;有了F0之后，我们使用Fresnel-Schlick近似来计算菲涅尔方程的近似：&lt;/p&gt;
&lt;div class="math"&gt;$$F(h,v,F_{0})=F_{0}+(1-F_{0})(1-h\cdot v)^{5}$$&lt;/div&gt;
&lt;p&gt;在glsl中的实现则为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;fresnelSchlick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;cosTheta&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;F0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;F0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;F0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;cosTheta&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中cosTheta则为HdotV&lt;/p&gt;
&lt;p&gt;终于，我们计算出了BRDF公式中的所有近似项，并且，我们有了两项粗糙度（Roughness）以及金属度（Metallic）两项额外的参数可以用于调整渲染效果，这两个参数的取值范围均为[0, 1]&lt;/p&gt;
&lt;hr&gt;
&lt;h2&gt;直接光照明&lt;/h2&gt;
&lt;p&gt;接下来，在得到了BRDF的真实公式之后，我们尝试基于公式直接计算直接光的照明，我们会在场景中添加若干个点光源，以及一个方向光源，首先我们定义光源的一些基本变量：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#define POINT_LIGHT_NUMBER ${PointLightPositions.size}&lt;/span&gt;
&lt;span class="c1"&gt;// lights&lt;/span&gt;
&lt;span class="k"&gt;uniform&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;pointLightPositions&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;POINT_LIGHT_NUMBER&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="k"&gt;uniform&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;pointLightColors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;POINT_LIGHT_NUMBER&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;uniform&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;directionLightDir&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;uniform&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;directionLightColor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们将点光源的位置以及颜色分别存储在数组中，而对于方向光源，则分别需要声明起方向以及颜色，而实际在光照计算，我们需要对遍历每一个光源，分别使用BRDF函数计算其最终反射的颜色并相加起来&lt;/p&gt;
&lt;p&gt;我们首先来看下点光源的计算，由于点光源强度会随着距离而进行衰减，这里我们使用&lt;a href="https://learnopengl-cn.github.io/02%20Lighting/05%20Light%20casters/#_3"&gt;这里教程&lt;/a&gt;介绍到的平方衰减函数，单个点光源的完整计算逻辑如下&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// calculate per-light radiance&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointLightPositions&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;WorldPos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointLightPositions&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;WorldPos&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;attenuation&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointLightColors&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;attenuation&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Cook-Torrance BRDF&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NDF&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DistributionGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GeometrySmith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fresnelSchlick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clamp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;F0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;nominator&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NDF&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;denominator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;4.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;specular&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nominator&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;denominator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// prevent divide by zero for NdotV=0.0 or NdotL=0.0&lt;/span&gt;
&lt;span class="c1"&gt;// kS is equal to Fresnel&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;kS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// for energy conservation, the diffuse and specular light can&amp;#39;t&lt;/span&gt;
&lt;span class="c1"&gt;// be above 1.0 (unless the surface emits light); to preserve this&lt;/span&gt;
&lt;span class="c1"&gt;// relationship the diffuse component (kD) should equal 1.0 - kS.&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;kS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// multiply kD by the inverse metalness such that only non-metals&lt;/span&gt;
&lt;span class="c1"&gt;// have diffuse lighting, or a linear blend if partly metal (pure metals&lt;/span&gt;
&lt;span class="c1"&gt;// have no diffuse light).&lt;/span&gt;
&lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;metallic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// scale light by NdotL&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// add to outgoing radiance Lo&lt;/span&gt;
&lt;span class="c1"&gt;// note that we already multiplied the BRDF by the Fresnel (kS so we won&amp;#39;t multiply by kS again&lt;/span&gt;
&lt;span class="n"&gt;Lo&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;albedo&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;PI&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;specular&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出来实现基本上就是直接对着公式翻译了一遍，注意在计算kD的时候，我们最后还乘以了（1.0-metallic），这说明在表面材质完全是金属的时候，将不会有漫反射&lt;/p&gt;
&lt;p&gt;对于方向光源，我们也是类似这样子计算：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;directionLightDir&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;normalize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;V&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;directionLightColor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// Cook-Torrance BRDF&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NDF&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;DistributionGGX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt;   &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;GeometrySmith&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;roughness&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;fresnelSchlick&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clamp&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;H&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;F0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;nominator&lt;/span&gt;    &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NDF&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;G&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;denominator&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;4.0&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;V&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;specular&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;nominator&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;denominator&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0.001&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// prevent divide by zero for NdotV=0.0 or NdotL=0.0&lt;/span&gt;
&lt;span class="c1"&gt;// kS is equal to Fresnel&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;kS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;F&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// for energy conservation, the diffuse and specular light can&amp;#39;t&lt;/span&gt;
&lt;span class="c1"&gt;// be above 1.0 (unless the surface emits light); to preserve this&lt;/span&gt;
&lt;span class="c1"&gt;// relationship the diffuse component (kD) should equal 1.0 - kS.&lt;/span&gt;
&lt;span class="k"&gt;vec3&lt;/span&gt; &lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;kS&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// multiply kD by the inverse metalness such that only non-metals&lt;/span&gt;
&lt;span class="c1"&gt;// have diffuse lighting, or a linear blend if partly metal (pure metals&lt;/span&gt;
&lt;span class="c1"&gt;// have no diffuse light).&lt;/span&gt;
&lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;*=&lt;/span&gt; &lt;span class="mf"&gt;1.0&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;metallic&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="c1"&gt;// scale light by NdotL&lt;/span&gt;
&lt;span class="k"&gt;float&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;max&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dot&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;N&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;L&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mf"&gt;0.0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="c1"&gt;// add to outgoing radiance Lo&lt;/span&gt;
&lt;span class="c1"&gt;// note that we already multiplied the BRDF by the Fresnel (kS) so we won&amp;#39;t multiply by kS again&lt;/span&gt;
&lt;span class="n"&gt;Lo&lt;/span&gt; &lt;span class="o"&gt;+=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;kD&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;albedo&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;specular&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;radiance&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;NdotL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;注意跟点光源计算不同，我们在计算的时候并没有根据距离来衰减光照能量&lt;/p&gt;
&lt;p&gt;最后，在计算出光照颜色之后，由于我们整个计算过程都是在线性空间中计算，并且没有对输出颜色归一，所以最后我们还需要进行Gamma校正以及色调映射（Tone Mapping）:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="c1"&gt;// HDR tonemapping&lt;/span&gt;
&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;/&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;span class="c1"&gt;// gamma correct&lt;/span&gt;
&lt;span class="n"&gt;color&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pow&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;color&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;vec3&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2.2&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;下图便是在Android中，在不同的粗糙度下的渲染结果：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/android_pbr_direct_light_render_roughness.jpg"&gt;&lt;/p&gt;
&lt;p&gt;本文章具体实现代码在：&lt;a href="https://github.com/ragnraok/AndroidPBR"&gt;AndroidPBR&lt;/a&gt;，渲染的界面提供了两个slidebar用于调整金属度以及粗糙度参数&lt;/p&gt;
&lt;p&gt;PBR管线除了直接光照明部分以外，还有环境光照明部分，这部分是PBR对比与上一世代光照模型的一个很重要的区别，所谓全局光照的实体，我将会在下一篇文章尝试介绍这一部分的内容&lt;/p&gt;
&lt;h2&gt;References&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;PBR理论介绍: &lt;a href="https://learnopengl-cn.github.io/07%20PBR/01%20Theory/"&gt;https://learnopengl-cn.github.io/07%20PBR/01%20Theory/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PBR直接光照明实现: &lt;a href="https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/"&gt;https://learnopengl-cn.github.io/07%20PBR/02%20Lighting/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;PBR白皮书: &lt;a href="https://zhuanlan.zhihu.com/p/53086060"&gt;https://zhuanlan.zhihu.com/p/53086060&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;script type="text/javascript"&gt;if (!document.getElementById('mathjaxscript_pelican_#%@#$@#')) {
    var align = "center",
        indent = "0em",
        linebreak = "false";

    if (true) {
        align = (screen.width &lt; 768) ? "left" : align;
        indent = (screen.width &lt; 768) ? "0em" : indent;
        linebreak = (screen.width &lt; 768) ? 'true' : linebreak;
    }

    var mathjaxscript = document.createElement('script');
    mathjaxscript.id = 'mathjaxscript_pelican_#%@#$@#';
    mathjaxscript.type = 'text/javascript';
    mathjaxscript.src = 'https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.3/latest.js?config=TeX-AMS-MML_HTMLorMML';

    var configscript = document.createElement('script');
    configscript.type = 'text/x-mathjax-config';
    configscript[(window.opera ? "innerHTML" : "text")] =
        "MathJax.Hub.Config({" +
        "    config: ['MMLorHTML.js']," +
        "    TeX: { extensions: ['AMSmath.js','AMSsymbols.js','noErrors.js','noUndefined.js'], equationNumbers: { autoNumber: 'none' } }," +
        "    jax: ['input/TeX','input/MathML','output/HTML-CSS']," +
        "    extensions: ['tex2jax.js','mml2jax.js','MathMenu.js','MathZoom.js']," +
        "    displayAlign: '"+ align +"'," +
        "    displayIndent: '"+ indent +"'," +
        "    showMathMenu: true," +
        "    messageStyle: 'normal'," +
        "    tex2jax: { " +
        "        inlineMath: [ ['\\\\(','\\\\)'] ], " +
        "        displayMath: [ ['$$','$$'] ]," +
        "        processEscapes: true," +
        "        preview: 'TeX'," +
        "    }, " +
        "    'HTML-CSS': { " +
        "        availableFonts: ['STIX', 'TeX']," +
        "        preferredFont: 'STIX'," +
        "        styles: { '.MathJax_Display, .MathJax .mo, .MathJax .mi, .MathJax .mn': {color: 'inherit ! important'} }," +
        "        linebreaks: { automatic: "+ linebreak +", width: '90% container' }," +
        "    }, " +
        "}); " +
        "if ('default' !== 'default') {" +
            "MathJax.Hub.Register.StartupHook('HTML-CSS Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax['HTML-CSS'].FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
            "MathJax.Hub.Register.StartupHook('SVG Jax Ready',function () {" +
                "var VARIANT = MathJax.OutputJax.SVG.FONTDATA.VARIANT;" +
                "VARIANT['normal'].fonts.unshift('MathJax_default');" +
                "VARIANT['bold'].fonts.unshift('MathJax_default-bold');" +
                "VARIANT['italic'].fonts.unshift('MathJax_default-italic');" +
                "VARIANT['-tex-mathit'].fonts.unshift('MathJax_default-italic');" +
            "});" +
        "}";

    (document.body || document.getElementsByTagName('head')[0]).appendChild(configscript);
    (document.body || document.getElementsByTagName('head')[0]).appendChild(mathjaxscript);
}
&lt;/script&gt;</content></entry><entry><title>浅谈Android中Surface显示延迟处理</title><link href="http://ragnraok.github.io/surface_display_lag.html" rel="alternate"></link><published>2018-06-20T00:00:00+08:00</published><updated>2018-06-20T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2018-06-20:/surface_display_lag.html</id><summary type="html">&lt;p&gt;最近在使用GLES在Surface上渲染结果的时候，遇到了一个显示延迟的问题，当渲染时间过长，同时帧率要求比较高的时候，如果不加控制，就会造成显示的延迟，如果界面没有交互，倒是不会看出什么问题，如果是强交互的场景，这种情况下就会造成可感知的用户使用延迟了。处理这种情况的其中一种方式是给渲染的一帧赋予一个时间戳，用于给SurfaceFlinger进行对应的丢帧控制，具体什么原理呢，让我们一步一步来说明一下&lt;/p&gt;
&lt;h3&gt;Surface是什么？&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;从原来上讲，Android的 &lt;a href="https://developer.android.com/reference/android/view/Surface"&gt;Surface&lt;/a&gt; 可以认为是目前图形架构中，作为 &lt;a href="https://source.android.com/devices/graphics/arch-bq-gralloc"&gt;BufferQueue&lt;/a&gt; 的生产者端，Android会首先把内容渲染到Surface上，填充数据到GraphicBuffer上。而作为消费者端则为系统的&lt;a href="https://source.android.com/devices/graphics/arch-sf-hwc"&gt;SurfaceFlinger&lt;/a&gt; ，取出BufferQueue中的GraphicBuffer，并配合vysnc将数据送给HWC合成到屏幕上。&lt;/p&gt;
&lt;p&gt;一般来说，Android会把所有可见的View渲染到一个由SurfaceFlinger创建的Surface上，但是这个Surface并不能由开发者直接操作，从App的开发角度来看，大部分情况下我们直接操作的Surface一般会从以下两个地方获取&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/reference/android/view/SurfaceView"&gt;SurfaceView&lt;/a&gt; / &lt;a href="https://kapeli.com/dash_share?docset_file=Android&amp;amp;docset_name=Android&amp;amp;path=developer.android.com/reference/android/opengl/GLSurfaceView.html&amp;amp;platform=android&amp;amp;repo=Main&amp;amp;source=https://developer.android.com/reference/android/opengl/GLSurfaceView.html&amp;amp;version=8.1.0"&gt;GLSurfaceView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两个组件是结合了Surface跟View的实现，特别的是，这两个view系统为其单独提供一层了Surface，并直接由SurfaceFlinger进行管理合成，因此实际显示在屏幕上的时候，并没有完全从属在当前的View的布局层次上，在布局对应的位置上，只是一个透明的占位符。而GLSurfaceView，则在SurfaceView的基础上提供了EGL的上下文，以便可以直接使用GLES在Surface上绘制内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/reference/android/graphics/SurfaceTexture"&gt;SurfaceTexture&lt;/a&gt; / &lt;a href="https://developer.android.com/reference/android/view/TextureView"&gt;TextureView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SurfaceTexture是从Android 3 …&lt;/p&gt;&lt;/li&gt;&lt;/ul&gt;</summary><content type="html">&lt;p&gt;最近在使用GLES在Surface上渲染结果的时候，遇到了一个显示延迟的问题，当渲染时间过长，同时帧率要求比较高的时候，如果不加控制，就会造成显示的延迟，如果界面没有交互，倒是不会看出什么问题，如果是强交互的场景，这种情况下就会造成可感知的用户使用延迟了。处理这种情况的其中一种方式是给渲染的一帧赋予一个时间戳，用于给SurfaceFlinger进行对应的丢帧控制，具体什么原理呢，让我们一步一步来说明一下&lt;/p&gt;
&lt;h3&gt;Surface是什么？&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;从原来上讲，Android的 &lt;a href="https://developer.android.com/reference/android/view/Surface"&gt;Surface&lt;/a&gt; 可以认为是目前图形架构中，作为 &lt;a href="https://source.android.com/devices/graphics/arch-bq-gralloc"&gt;BufferQueue&lt;/a&gt; 的生产者端，Android会首先把内容渲染到Surface上，填充数据到GraphicBuffer上。而作为消费者端则为系统的&lt;a href="https://source.android.com/devices/graphics/arch-sf-hwc"&gt;SurfaceFlinger&lt;/a&gt; ，取出BufferQueue中的GraphicBuffer，并配合vysnc将数据送给HWC合成到屏幕上。&lt;/p&gt;
&lt;p&gt;一般来说，Android会把所有可见的View渲染到一个由SurfaceFlinger创建的Surface上，但是这个Surface并不能由开发者直接操作，从App的开发角度来看，大部分情况下我们直接操作的Surface一般会从以下两个地方获取&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/reference/android/view/SurfaceView"&gt;SurfaceView&lt;/a&gt; / &lt;a href="https://kapeli.com/dash_share?docset_file=Android&amp;amp;docset_name=Android&amp;amp;path=developer.android.com/reference/android/opengl/GLSurfaceView.html&amp;amp;platform=android&amp;amp;repo=Main&amp;amp;source=https://developer.android.com/reference/android/opengl/GLSurfaceView.html&amp;amp;version=8.1.0"&gt;GLSurfaceView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;这两个组件是结合了Surface跟View的实现，特别的是，这两个view系统为其单独提供一层了Surface，并直接由SurfaceFlinger进行管理合成，因此实际显示在屏幕上的时候，并没有完全从属在当前的View的布局层次上，在布局对应的位置上，只是一个透明的占位符。而GLSurfaceView，则在SurfaceView的基础上提供了EGL的上下文，以便可以直接使用GLES在Surface上绘制内容&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://developer.android.com/reference/android/graphics/SurfaceTexture"&gt;SurfaceTexture&lt;/a&gt; / &lt;a href="https://developer.android.com/reference/android/view/TextureView"&gt;TextureView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;SurfaceTexture是从Android 3.0+开始提供的组件，提供了一个Surface跟GLES纹理的组合，而TextureView，则是一个SurfaceTexture跟View结合起来的组件。而TextureView跟SurfaceView最大的不同在于，虽然都是可以作为BufferQueue的生产方，但是最后合成的时候，并非由SurfaceFlinger直接合成，而是通过GLES直接合成到App对应的Surface上，在布局层次上是跟当前App的View是在同一个层级，对应的View的刷新逻辑也会影响TextureView。因此，从原理上来说，SurfaceView/GLSurfaceView的渲染效率要比TextureView要高&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;使用GLES在Surface中显示内容&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;上面说到，Surface作为BufferQueue的生产方，开发者可以在上面绘制画面，而在SurfaceView/TextureView上，系统都提供了对应的&lt;code&gt;lockCanvas&lt;/code&gt;方法，返回一个&lt;code&gt;Canvas&lt;/code&gt;对象允许在对应的Surface上绘制内容。除了这个方法以外，我们也可以使用GLES在Surface上绘制内容。&lt;/p&gt;
&lt;p&gt;无论是使用GLSurfaceView，还是TextureView，使用GLES在Surface上绘制内容，我们都必须在单独线程进行GLES的上下文初始化（因为GL Context是跟线程绑定的），创建对应的&lt;a href="https://source.android.com/devices/graphics/arch-egl-opengl"&gt;EGLSurface&lt;/a&gt; ，一般来说，实现的代码如下（如果用的是GLSurfaceView，下面的初始化逻辑内部已经给你做好了）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mEGLDisplay&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eglGetDisplay&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_DEFAULT_DISPLAY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mEGLDisplay&lt;/span&gt; &lt;span class="p"&gt;===&lt;/span&gt; &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_NO_DISPLAY&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;RuntimeException&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unable to get EGL14 display&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="py"&gt;version&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IntArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eglInitialize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mEGLDisplay&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;version&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;throw&lt;/span&gt; &lt;span class="n"&gt;RuntimeException&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;unable to initialize EGL14&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;// Configure EGL for recording and OpenGL ES 2.0.&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="py"&gt;attribList&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;intArrayOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_RED_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                            &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_GREEN_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                            &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_BLUE_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                            &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_ALPHA_SIZE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;8&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                            &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_RENDERABLE_TYPE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_OPENGL_ES2_BIT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;                 
                            &lt;span class="n"&gt;EGL_RECORDABLE_ANDROID&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                            &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_NONE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="py"&gt;configs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arrayOfNulls&lt;/span&gt;&lt;span class="p"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;EGLConfig&lt;/span&gt;&lt;span class="p"&gt;&amp;gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="py"&gt;numConfigs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;IntArray&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eglChooseConfig&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mEGLDisplay&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attribList&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;configs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;configs&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;numConfigs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;checkEglError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;eglCreateContext RGB888+recordable ES2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// Configure context for OpenGL ES 2.0.&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="py"&gt;attrib_list&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;intArrayOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_CONTEXT_CLIENT_VERSION&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_NONE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;mEGLContext&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eglCreateContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mEGLDisplay&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;configs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_NO_CONTEXT&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;attrib_list&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;checkEglError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;eglCreateContext&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="c1"&gt;// Create a window surface, and attach it to the Surface we received.&lt;/span&gt;
&lt;span class="k"&gt;val&lt;/span&gt; &lt;span class="py"&gt;surfaceAttribs&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;intArrayOf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;EGL_NONE&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;mEGLSurface&lt;/span&gt; &lt;span class="p"&gt;=&lt;/span&gt; &lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eglCreateWindowSurface&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mEGLDisplay&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;configs&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;mSurface&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;surfaceAttribs&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;checkEglError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;eglCreateWindowSurface&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

&lt;span class="n"&gt;EGL14&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;eglMakeCurrent&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mEGLDisplay&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mEGLSurface&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mEGLSurface&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;mEGLContext&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;checkEglError&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;eglMakeCurrent&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;以上代码摘自&lt;a href="https://bigflake.com/mediacodec/CameraToMpegTest.java.txt"&gt;这里&lt;/a&gt;，并转换成了kotlin&lt;/p&gt;
&lt;p&gt;大概流程就是先选择好需要的EGL配置，然后初始化EGLConfig跟EGLContext，最终，调用&lt;code&gt;eglCreatexxxSurface&lt;/code&gt;创建一个EGLSurface，这这个例子中调用的是&lt;code&gt;eglCreateWindowSurface&lt;/code&gt;，并在函数中传入了SurfaceView/TextureView中的Surface对象````&lt;/p&gt;
&lt;p&gt;另外，在&lt;code&gt;eglCreateWindowSurface&lt;/code&gt;函数中传入的Surface对象，如果不是需要渲染到屏幕上的话，除了直接使用上面的两个Surface对象以外，在很多处理视频特效的应用中，另外一种方式是传入MediaCodec的Surface，也就是这个方法的返回结果&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;MediaCodec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInputSurface&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后MediaCodec作为编码器使用，渲染一帧之后结果就直接编码到结果视频中了&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;em&gt;这里简单在说明一点，在这种场景下（还有一种是使用GLES渲染camera preview），使用GLES渲染对应MediaCodec编码结果到Input Surface上的时候，使用的纹理类型必须是外部纹理（&lt;code&gt;GL_TEXTURE_EXTERNAL_OES&lt;/code&gt;）&lt;/em&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在上面的初始化代码中，最终结果是创建了一个&lt;code&gt;EGLSurface&lt;/code&gt;对象，这个对象最终会链接到Surface中的BufferQueue生产方接口，渲染到该EGLSurface上的新的一帧将会让一个GraphicBuffer离开队列并提供给消费者一方使用，但是，EGL并不会自动给提交当前渲染的一帧，当渲染好之后，需要调用&lt;code&gt;eglSwapBuffers&lt;/code&gt;提交当前渲染结果，从而实现BufferQueue的刷新&lt;/p&gt;
&lt;p&gt;结合SurfaceFlinger，使用GLES在Surface上渲染，上屏的整理流程大概如下：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Surface -&amp;gt; EGL renderer -&amp;gt; swap buffer -&amp;gt; BufferQueue deque -&amp;gt; SurfaceFlinger -&amp;gt; HWC -&amp;gt; Display&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;更具体的GraphicBuffer/BufferQueue同步机制，推荐看下&lt;a href="https://blog.csdn.net/jinzhuojun/article/details/39698317"&gt;这篇&lt;/a&gt;文章的分析&lt;/p&gt;
&lt;h3&gt;Surface渲染上屏时间戳&lt;/h3&gt;
&lt;hr&gt;
&lt;p&gt;上面大体分析了Surface原理，以及对应渲染上屏的步骤，但是，直到SurfaceFlinger，到Hareware Composer这一步，我们还有一个关键的问题没有解决：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;我们在渲染好一帧之后，如何能够保证这一帧的内容能够及时显示到屏幕上呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;或者换一个问法：&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;当我们渲染一帧的时间过长的时候，我们又怎么能够保证在对应的时间点上在屏幕上显示对应的内容呢？&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;如果没有解决这个问题，那么在游戏渲染，或者在视频播放渲染的时候，就很容易出现音视频不同步的情况。而Android对于这个问题的解决方式就是，让App去告诉SurfaceFlinger某一帧想要在哪个时间点显示到屏幕上，也就是说引入了帧时间戳的概念。当SurfaceFlinger提交到HWC超过这个时间戳的时候，就丢掉这一帧，如果还没达到对应帧的时间戳，就继续显示当前帧&lt;/p&gt;
&lt;p&gt;而在实现上，Android提供了一个单独的EGL扩展：&lt;a href="https://www.khronos.org/registry/EGL/extensions/ANDROID/EGL_ANDROID_presentation_time.txt"&gt;eglPresentationTimeANDROID&lt;/a&gt; ，在swapBuffer之前调用，提交当前帧的想要的显示时间戳，至于时间戳的具体含义，在不同的场景中可能会有不同的表达，例如：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;如果是显示到屏幕上的时候，时间戳就是一个绝对时间值，例如系统的启动时间&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;如果是视频编码的场景，例如使用MediaCodec的InputSurface来编码视频的时候，这个时候时间戳的含义就是当前视频帧的 &lt;a href="https://en.wikipedia.org/wiki/Presentation_timestamp"&gt;pts&lt;/a&gt;，事实上，当你想在MediaCodec的InputSurface上渲染完内容之后，如果不调用这个函数控制当前这一帧的pts，除非合成器有额外控制，否则最后编码出来的视频fps将会相当大，具体这里的实现，可以参考下BigFlake这里的&lt;a href="https://bigflake.com/mediacodec/EncodeAndMuxTest.java.txt"&gt;代码&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;btw, 这个扩展对应的Android上层接口定义在&lt;a href="https://developer.android.com/reference/android/opengl/EGLExt.html"&gt;这里&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;因此，通过对 &lt;code&gt;eglPresentationTimeANDROID&lt;/code&gt; 的调用，结合BufferQueue，SurfaceFlinger就可以针对上屏的每一帧数据延迟做精确的控制了，假设说，我们设置了某一帧显示时间戳为&lt;strong&gt;T&lt;/strong&gt;，然后提交到BufferQueue中：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;当在&lt;strong&gt;T-1&lt;/strong&gt;的时间点，当前队首为这一帧的时候，SurfaceFlinger会继续hold住当前帧，也就是说这个时候显示的还是前一帧的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当达到了&lt;strong&gt;T&lt;/strong&gt;时间点，当前队首为这一帧的时候，SurfaceFlinger便直接提交这一帧到Display&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;当达到了&lt;strong&gt;T+1&lt;/strong&gt;时间点，当前队首为这一帧的时候，因为已经超过了这一帧设置的时间戳&lt;strong&gt;T&lt;/strong&gt;，因此SurfaceFlinger便直接&lt;strong&gt;丢弃&lt;/strong&gt;这一帧，继续处理队列剩余的帧数据&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;总体来看，在通过帧时间戳控制之后，Android就可以解决Surface的渲染上屏延迟问题，但渲染过长的时候，就势必带来丢帧，因此根本的解决方案，还是得尽量在16ms内，渲染完一帧数据&lt;/p&gt;
&lt;p&gt;文笔一般，水平有限，仅做抛砖引玉之用，欢迎更加仔细的讨论!&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;hr&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://stackoverflow.com/questions/26317132/minimize-android-glsurfaceview-lag/"&gt;StackOverFlow—Minimize Android GLSurfaceView Lag&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://blog.csdn.net/jinzhuojun/article/details/39698317"&gt;Android中的GraphicBuffer同步机制-Fence&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://www.khronos.org/registry/EGL/extensions/ANDROID/EGL_ANDROID_presentation_time.txt"&gt;EGL_ANDROID_presentation_time&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://source.android.com/devices/graphics/"&gt;Android图形架构&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="https://bigflake.com/mediacodec/"&gt;Android MediaCodec Stuff&lt;/a&gt;````&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>谈谈关于Android视频编码的那些坑</title><link href="http://ragnraok.github.io/android_video_record.html" rel="alternate"></link><published>2017-08-27T00:00:00+08:00</published><updated>2017-08-27T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2017-08-27:/android_video_record.html</id><summary type="html">&lt;p&gt;Android的视频相关的开发，大概一直是整个Android生态，以及Android API中，最为分裂以及兼容性问题最为突出的一部分。摄像头，以及视频编码相关的API，Google一直对这方面的控制力非常差，导致不同厂商对这两个API的实现有不少差异，而且从API的设计来看，一直以来优化也相当有限，甚至有人认为这是“Android上最难用的API之一”&lt;/p&gt;
&lt;p&gt;以微信为例，我们录制一个540p的mp4文件，对于Android来说，大体上是遵循这么一个流程：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img alt="" src="static/images/encoderProcess.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大体上就是从摄像头输出的YUV帧经过预处理之后，送入编码器，获得编码好的h264视频流。&lt;/p&gt;
&lt;p&gt;上面只是针对视频流的编码，另外还需要对音频流单独录制，最后再将视频流和音频流进行合成出最终视频。&lt;/p&gt;
&lt;p&gt;这篇文章主要将会对视频流的编码中两个常见问题进行分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;视频编码器的选择（硬编 or 软编）？&lt;/li&gt;
&lt;li&gt;如何对摄像头输出的YUV帧进行快速预处理（镜像，缩放，旋转）？&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;视频编码器的选择&lt;/h3&gt;
&lt;p&gt;对于录制视频的需求，不少app都需要对每一帧数据进行单独处理，因此很少会直接用到&lt;code&gt;MediaRecorder&lt;/code&gt;来直接录取视频，一般来说，会有这么两个选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MediaCodec&lt;/li&gt;
&lt;li&gt;FFMpeg+x264/openh264&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来逐个解析一下&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;MediaCodec&lt;/h4&gt;
&lt;p&gt;MediaCodec是API 16之后Google推出的用于音视频编解码的一套偏底层的API，可以直接利用硬件加速进行视频的编解码。调用的时候需要先初始化MediaCodec作为视频的编码器 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Android的视频相关的开发，大概一直是整个Android生态，以及Android API中，最为分裂以及兼容性问题最为突出的一部分。摄像头，以及视频编码相关的API，Google一直对这方面的控制力非常差，导致不同厂商对这两个API的实现有不少差异，而且从API的设计来看，一直以来优化也相当有限，甚至有人认为这是“Android上最难用的API之一”&lt;/p&gt;
&lt;p&gt;以微信为例，我们录制一个540p的mp4文件，对于Android来说，大体上是遵循这么一个流程：&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;&lt;img alt="" src="static/images/encoderProcess.png"&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;大体上就是从摄像头输出的YUV帧经过预处理之后，送入编码器，获得编码好的h264视频流。&lt;/p&gt;
&lt;p&gt;上面只是针对视频流的编码，另外还需要对音频流单独录制，最后再将视频流和音频流进行合成出最终视频。&lt;/p&gt;
&lt;p&gt;这篇文章主要将会对视频流的编码中两个常见问题进行分析：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;视频编码器的选择（硬编 or 软编）？&lt;/li&gt;
&lt;li&gt;如何对摄像头输出的YUV帧进行快速预处理（镜像，缩放，旋转）？&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h3&gt;视频编码器的选择&lt;/h3&gt;
&lt;p&gt;对于录制视频的需求，不少app都需要对每一帧数据进行单独处理，因此很少会直接用到&lt;code&gt;MediaRecorder&lt;/code&gt;来直接录取视频，一般来说，会有这么两个选择&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;MediaCodec&lt;/li&gt;
&lt;li&gt;FFMpeg+x264/openh264&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我们来逐个解析一下&lt;/p&gt;
&lt;hr&gt;
&lt;h4&gt;MediaCodec&lt;/h4&gt;
&lt;p&gt;MediaCodec是API 16之后Google推出的用于音视频编解码的一套偏底层的API，可以直接利用硬件加速进行视频的编解码。调用的时候需要先初始化MediaCodec作为视频的编码器，然后只需要不停传入原始的YUV数据进入编码器就可以直接输出编码好的h264流，整个API设计模型来看，就是同时包含了输入端和输出端的两条队列：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/mediacodec_buffers.png"&gt;&lt;/p&gt;
&lt;p&gt;因此，作为编码器，输入端队列存放的就是原始YUV数据，输出端队列输出的就是编码好的h264流，作为解码器则对应相反。在调用的时候，MediaCodec提供了同步和异步两种调用方式，但是异步使用Callback的方式是在API 21之后才加入的，以同步调用为例，一般来说调用方式大概是这样（摘自官方例子）：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt; &lt;span class="n"&gt;MediaCodec&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;MediaCodec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createByCodecName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
 &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;configure&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;format&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
 &lt;span class="n"&gt;MediaFormat&lt;/span&gt; &lt;span class="n"&gt;outputFormat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getOutputFormat&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// option B&lt;/span&gt;
 &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
 &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(;;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
   &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;inputBufferId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;dequeueInputBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeoutUs&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputBufferId&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;ByteBuffer&lt;/span&gt; &lt;span class="n"&gt;inputBuffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInputBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="c1"&gt;// fill inputBuffer with valid data&lt;/span&gt;
     &lt;span class="err"&gt;…&lt;/span&gt;
     &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;queueInputBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;inputBufferId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
   &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;outputBufferId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;dequeueOutputBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputBufferId&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;ByteBuffer&lt;/span&gt; &lt;span class="n"&gt;outputBuffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getOutputBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputBufferId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
     &lt;span class="n"&gt;MediaFormat&lt;/span&gt; &lt;span class="n"&gt;bufferFormat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getOutputFormat&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputBufferId&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt; &lt;span class="c1"&gt;// option A&lt;/span&gt;
     &lt;span class="c1"&gt;// bufferFormat is identical to outputFormat&lt;/span&gt;
     &lt;span class="c1"&gt;// outputBuffer is ready to be processed or rendered.&lt;/span&gt;
     &lt;span class="err"&gt;…&lt;/span&gt;
     &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;releaseOutputBuffer&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputBufferId&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="err"&gt;…&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;outputBufferId&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;MediaCodec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;INFO_OUTPUT_FORMAT_CHANGED&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
     &lt;span class="c1"&gt;// Subsequent data will conform to new format.&lt;/span&gt;
     &lt;span class="c1"&gt;// Can ignore if using getOutputFormat(outputBufferId)&lt;/span&gt;
     &lt;span class="n"&gt;outputFormat&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getOutputFormat&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt; &lt;span class="c1"&gt;// option B&lt;/span&gt;
   &lt;span class="o"&gt;}&lt;/span&gt;
 &lt;span class="o"&gt;}&lt;/span&gt;
 &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
 &lt;span class="n"&gt;codec&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;release&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;简单解释一下，通过&lt;code&gt;getInputBuffers&lt;/code&gt;获取输入队列，然后调用&lt;code&gt;dequeueInputBuffer&lt;/code&gt;获取输入队列空闲数组下标，注意&lt;code&gt;dequeueOutputBuffer&lt;/code&gt;会有几个特殊的返回值表示当前编解码状态的变化，然后再通过&lt;code&gt;queueInputBuffer&lt;/code&gt;把原始YUV数据送入编码器，而在输出队列端同样通过&lt;code&gt;getOutputBuffers&lt;/code&gt;和&lt;code&gt;dequeueOutputBuffer&lt;/code&gt;获取输出的h264流，处理完输出数据之后，需要通过&lt;code&gt;releaseOutputBuffer&lt;/code&gt;把输出buffer还给系统，重新放到输出队列中。&lt;br /&gt;
关于MediaCodec更复杂的使用例子，可以参照下CTS测试里面的使用方式：&lt;a href="https://android.googlesource.com/platform/cts/+/jb-mr2-release/tests/tests/media/src/android/media/cts/EncodeDecodeTest.java"&gt;EncodeDecodeTest.java&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;从上面例子来看的确是非常原始的API，由于MediaCodec底层是直接调用了手机平台硬件的编解码能力，所以速度非常快，但是因为Google对整个Android硬件生态的掌控力非常弱，所以这个API有很多问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;颜色格式问题&lt;/p&gt;
&lt;p&gt;MediaCodec在初始化的时候，在&lt;code&gt;configure&lt;/code&gt;的时候，需要传入一个MediaFormat对象，当作为编码器使用的时候，我们一般需要在MediaFormat中指定视频的宽高，帧率，码率，I帧间隔等基本信息，除此之外，还有一个重要的信息就是，指定编码器接受的YUV帧的颜色格式。这个是因为由于YUV根据其采样比例，UV分量的排列顺序有很多种不同的颜色格式，而对于Android的摄像头在&lt;code&gt;onPreviewFrame&lt;/code&gt;输出的YUV帧格式，如果没有配置任何参数的情况下，基本上都是NV21格式，但Google对MediaCodec的API在设计和规范的时候，显得很不厚道，过于贴近Android的HAL层了，导致了NV21格式并不是所有机器的MediaCodec都支持这种格式作为编码器的输入格式！
因此，在初始化MediaCodec的时候，我们需要通过&lt;code&gt;codecInfo.getCapabilitiesForType&lt;/code&gt;来查询机器上的MediaCodec实现具体支持哪些YUV格式作为输入格式，一般来说，起码在4.4+的系统上，这两种格式在大部分机器都有支持：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420Planar
MediaCodecInfo.CodecCapabilities.COLOR_FormatYUV420SemiPlanar
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;两种格式分别是YUV420P和NV21，如果机器上只支持YUV420P格式的情况下，则需要先将摄像头输出的NV21格式先转换成YUV420P，才能送入编码器进行编码，否则最终出来的视频就会花屏，或者颜色出现错乱&lt;/p&gt;
&lt;p&gt;这个算是一个不大不小的坑，基本上用上了MediaCodec进行视频编码都会遇上这个问题&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;编码器支持特性相当有限&lt;/p&gt;
&lt;p&gt;如果使用MediaCodec来编码H264视频流，对于H264格式来说，会有一些针对压缩率以及码率相关的视频质量设置，典型的诸如Profile(baseline, main, high)，Profile Level, Bitrate mode(CBR, CQ, VBR)，合理配置这些参数可以让我们在同等的码率下，获得更高的压缩率，从而提升视频的质量，Android也提供了对应的API进行设置，可以设置到MediaFormat中这些设置项:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;MediaFormat.KEY_BITRATE_MODE
MediaFormat.KEY_PROFILE
MediaFormat.KEY_LEVEL
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;但问题是，对于Profile，Level, Bitrate mode这些设置，在大部分手机上都是不支持的，即使是设置了最终也不会生效，例如设置了Profile为high，最后出来的视频依然还会是Baseline，Shit....&lt;/p&gt;
&lt;p&gt;这个问题，在7.0以下的机器几乎是必现的，其中一个可能的原因是，Android在源码层级&lt;a href="http://androidxref.com/6.0.1_r10/xref/frameworks/av/media/libstagefright/ACodec.cpp"&gt;hardcode&lt;/a&gt;了profile的的设置：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;// XXX
if (h264type.eProfile != OMX_VIDEO_AVCProfileBaseline) {
    ALOGW(&amp;quot;Use baseline profile instead of %d for AVC recording&amp;quot;,
            h264type.eProfile);
    h264type.eProfile = OMX_VIDEO_AVCProfileBaseline;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Android直到&lt;a href="http://androidxref.com/7.0.0_r1/xref/frameworks/av/media/libstagefright/ACodec.cpp"&gt;7.0&lt;/a&gt;之后才取消了这段地方的Hardcode&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (h264type.eProfile == OMX_VIDEO_AVCProfileBaseline) {
    ....
} else if (h264type.eProfile == OMX_VIDEO_AVCProfileMain ||
            h264type.eProfile == OMX_VIDEO_AVCProfileHigh) {
    .....
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这个问题可以说间接导致了MediaCodec编码出来的视频质量偏低，同等码率下，难以获得跟软编码甚至iOS那样的视频质量。   &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;16位对齐要求&lt;/p&gt;
&lt;p&gt;前面说到，MediaCodec这个API在设计的时候，过于贴近HAL层，这在很多Soc的实现上，是直接把传入MediaCodec的buffer，在不经过任何前置处理的情况下就直接送入了Soc中。而在编码h264视频流的时候，由于h264的编码块大小一般是16x16，于是乎在一开始设置视频的宽高的时候，如果设置了一个没有对齐16的大小，例如960x540，在某些cpu上，最终编码出来的视频就会直接&lt;strong&gt;花屏&lt;/strong&gt;！&lt;/p&gt;
&lt;p&gt;很明显这还是因为厂商在实现这个API的时候，对传入的数据缺少校验以及前置处理导致的，目前来看，华为，三星的Soc出现这个问题会比较频繁，其他厂商的一些早期Soc也有这种问题，一般来说解决方法还是在设置视频宽高的时候，统一设置成对齐16位之后的大小就好了。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;hr&gt;
&lt;h4&gt;FFMpeg+x264/openh264&lt;/h4&gt;
&lt;p&gt;除了使用MediaCodec进行编码之外，另外一种比较流行的方案就是使用ffmpeg+x264/openh264进行软编码，ffmpeg是用于一些视频帧的预处理。这里主要是使用x264/openh264作为视频的编码器。&lt;/p&gt;
&lt;p&gt;x264基本上被认为是当今市面上最快的商用视频编码器，而且基本上所有h264的特性都支持，通过合理配置各种参数还是能够得到较好的压缩率和编码速度的，限于篇幅，这里不再阐述h264的参数配置，有兴趣可以看下&lt;a href="https://www.nmm-hd.org/d/index.php?title=X264%E4%BD%BF%E7%94%A8%E4%BB%8B%E7%BB%8D&amp;amp;variant=zh-cn"&gt;这里&lt;/a&gt;和&lt;a href="http://www.cnblogs.com/wainiwann/p/5647521.html"&gt;这里&lt;/a&gt;对x264编码参数的调优。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/cisco/openh264"&gt;openh264&lt;/a&gt;则是由思科开源的另外一个h264编码器，项目在2013年开源，对比起x264来说略显年轻，不过由于思科支付满了h264的年度专利费，所以对于外部用户来说，相当于可以直接免费使用了，另外，firefox直接内置了openh264，作为其在webRTC中的视频的编解码器使用。&lt;/p&gt;
&lt;p&gt;但对比起x264，openh264在h264高级特性的支持比较差：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Profile只支持到baseline, level 5.2&lt;/li&gt;
&lt;li&gt;多线程编码只支持slice based，不支持frame based的多线程编码&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;从编码效率上来看，openh264的速度也并不会比x264快，不过其最大的好处，还是能够直接免费使用吧。&lt;/p&gt;
&lt;h4&gt;软硬编对比&lt;/h4&gt;
&lt;p&gt;从上面的分析来看，硬编的好处主要在于速度快，而且系统自带不需要引入外部的库，但是特性支持有限，而且硬编的压缩率一般偏低，而对于软编码来说，虽然速度较慢，但是压缩率比较高，而且支持的H264特性也会比硬编码多很多，相对来说比较可控。就可用性而言，在4.4+的系统上，MediaCodec的可用性是能够基本保证的，但是不同等级的机器的编码器能力会有不少差别，建议可以根据机器的配置，选择不同的编码器配置。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;YUV帧的预处理&lt;/h3&gt;
&lt;p&gt;根据最开始给出的流程，在送入编码器之前，我们需要先对摄像头输出的YUV帧进行一些前置处理&lt;/p&gt;
&lt;p&gt;1.缩放&lt;/p&gt;
&lt;p&gt;如果设置了camera的预览大小为1080p的情况下，在&lt;code&gt;onPreviewFrame&lt;/code&gt;中输出的YUV帧直接就是1920x1080的大小，如果需要编码跟这个大小不一样的视频，我们就需要在录制的过程中，&lt;strong&gt;实时&lt;/strong&gt;的对YUV帧进行缩放。&lt;/p&gt;
&lt;p&gt;以微信为例，摄像头预览1080p的数据，需要编码960x540大小的视频。&lt;/p&gt;
&lt;p&gt;最为常见的做法是使用ffmpeg这种的sws_scale函数进行直接缩放，效果/性能比较好的一般是选择SWS_FAST_BILINEAR算法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;mScaleYuvCtxPtr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;sws_getContext&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
                   &lt;span class="n"&gt;srcWidth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;srcHeight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;AV_PIX_FMT_NV21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;dstWidth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;dstHeight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;AV_PIX_FMT_NV21&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                   &lt;span class="n"&gt;SWS_FAST_BILINEAR&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;sws_scale&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;mScaleYuvCtxPtr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="kt"&gt;uint8_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;srcAvPicture&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;srcAvPicture&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;linesize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;srcHeight&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                    &lt;span class="n"&gt;dstAvPicture&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dstAvPicture&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;linesize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在nexus 6p上，直接使用ffmpeg来进行缩放的时间基本上都需要&lt;strong&gt;40ms+&lt;/strong&gt;，对于我们需要录制30fps的来说，每帧处理时间最多就30ms左右，如果光是缩放就消耗了如此多的时间，基本上录制出来的视频只能在15fps上下了。&lt;/p&gt;
&lt;p&gt;很明显，直接使用ffmpeg进行缩放是在是太慢了，不得不说swsscale简直就是ffmpeg里面的渣渣，在对比了几种业界常用的算之后，我们最后考虑实现使用这种快速缩放的算法：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/frame_compress.png"&gt;&lt;/p&gt;
&lt;p&gt;我们选择一种叫做的&lt;strong&gt;局部均值&lt;/strong&gt;算法，前后两行四个临近点算出最终图片的四个像素点，对于源图片的每行像素，我们可以使用Neon直接实现，以缩放Y分量为例：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nf"&gt;const&lt;/span&gt; &lt;span class="no"&gt;uint8&lt;/span&gt;&lt;span class="p"&gt;*&lt;/span&gt; &lt;span class="no"&gt;src_next&lt;/span&gt; &lt;span class="err"&gt;=&lt;/span&gt; &lt;span class="no"&gt;src_ptr&lt;/span&gt; &lt;span class="err"&gt;+&lt;/span&gt; &lt;span class="no"&gt;src_stride&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
    &lt;span class="no"&gt;asm&lt;/span&gt; &lt;span class="no"&gt;volatile&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
      &lt;span class="err"&gt;&amp;quot;1:&lt;/span&gt;                                          &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nf"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;    
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;vld4.8&lt;/span&gt;     &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]!&lt;/span&gt;        &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vld4.8&lt;/span&gt;     &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;d4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d7&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]!&lt;/span&gt;        &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;subs&lt;/span&gt;       &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;#16                    \n&amp;quot;  // 16 processed per loop&lt;/span&gt;

        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vrhadd.u8&lt;/span&gt;   &lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d1&lt;/span&gt;                    &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vrhadd.u8&lt;/span&gt;   &lt;span class="no"&gt;d4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d5&lt;/span&gt;                    &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vrhadd.u8&lt;/span&gt;   &lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d4&lt;/span&gt;                    &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;

        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vrhadd.u8&lt;/span&gt;   &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d3&lt;/span&gt;                    &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vrhadd.u8&lt;/span&gt;   &lt;span class="no"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d7&lt;/span&gt;                    &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vrhadd.u8&lt;/span&gt;   &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d6&lt;/span&gt;                    &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;

        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vst2.8&lt;/span&gt;     &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]!&lt;/span&gt;                    &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;store&lt;/span&gt; &lt;span class="no"&gt;odd&lt;/span&gt; &lt;span class="no"&gt;pixels&lt;/span&gt;

        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;bgt&lt;/span&gt;        &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="no"&gt;b&lt;/span&gt;                             &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
      &lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;src_ptr&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;          &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;src_next&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;         &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;              &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;dst_width&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;         &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
      &lt;span class="err"&gt;:&lt;/span&gt;
      &lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;q0&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;q1&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;q2&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;q3&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;              &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;Clobber&lt;/span&gt; &lt;span class="no"&gt;List&lt;/span&gt;
    &lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面使用的Neon指令每次只能读取和存储8或者16位的数据，对于多出来的数据，只需要用同样的算法改成用C语言实现即可。&lt;/p&gt;
&lt;p&gt;在使用上述的算法优化之后，进行每帧缩放，在Nexus 6p上，只需要不到&lt;strong&gt;5ms&lt;/strong&gt;就能完成了，而对于缩放质量来说，ffmpeg的SWS_FAST_BILINEAR算法和上述算法缩放出来的图片进行对比，峰值信噪比（psnr）在大部分场景下大概在&lt;strong&gt;38-40&lt;/strong&gt;左右，质量也足够好了。&lt;/p&gt;
&lt;p&gt;2.旋转&lt;/p&gt;
&lt;p&gt;在android机器上，由于摄像头安装角度不同，&lt;code&gt;onPreviewFrame&lt;/code&gt;出来的YUV帧一般都是旋转了90或者270度，如果最终视频是要竖拍的，那一般来说需要把YUV帧进行旋转。&lt;/p&gt;
&lt;p&gt;对于旋转的算法，如果是纯C实现的代码，一般来说是个O（n^2 ） 复杂度的算法，如果是旋转960x540的yuv帧数据，在nexus 6p上，每帧旋转也需要&lt;strong&gt;30ms+&lt;/strong&gt;，这显然也是不能接受的。&lt;/p&gt;
&lt;p&gt;在这里我们换个思路，能不能不对YUV帧进行旋转？（当然是可以的6666）&lt;/p&gt;
&lt;p&gt;事实上在mp4文件格式的头部，我们可以指定一个旋转矩阵，具体来说是在&lt;strong&gt;moov.trak.tkhd box&lt;/strong&gt;里面指定，视频播放器在播放视频的时候，会在读取这里矩阵信息，从而决定视频本身的旋转角度，位移，缩放等，具体可以参考下苹果的&lt;a href="https://developer.apple.com/library/content/documentation/QuickTime/QTFF/QTFFChap4/qtff4.html#//apple_ref/doc/uid/TP40000939-CH206-18737"&gt;文档&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;通过ffmpeg，我们可以很轻松的给合成之后的mp4文件打上这个旋转角度：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kt"&gt;char&lt;/span&gt; &lt;span class="n"&gt;rotateStr&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;sprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rotateStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;%d&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rotate&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;av_dict_set&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;out_stream&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;metadata&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;rotate&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rotateStr&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;于是可以在录制的时候省下一大笔旋转的开销了，excited!&lt;/p&gt;
&lt;p&gt;3.镜像&lt;/p&gt;
&lt;p&gt;在使用前置摄像头拍摄的时候，如果不对YUV帧进行处理，那么直接拍出来的视频是会&lt;strong&gt;镜像翻转&lt;/strong&gt;的，这里原理就跟照镜子一样，从前置摄像头方向拿出来的YUV帧刚好是反的，但有些时候拍出来的镜像视频可能不合我们的需求，因此这个时候我们就需要对YUV帧进行镜像翻转。&lt;/p&gt;
&lt;p&gt;但由于摄像头安装角度一般是90或者270度，所以实际上原生的YUV帧是水平翻转过来的，因此做镜像翻转的时候，只需要刚好以中间为中轴，分别上下交换每行数据即可，注意Y跟UV要分开处理，这种算法用Neon实现相当简单：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nf"&gt;asm&lt;/span&gt; &lt;span class="no"&gt;volatile&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;
      &lt;span class="err"&gt;&amp;quot;1:&lt;/span&gt;                                          &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="nf"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vld4.8&lt;/span&gt;     &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;]!&lt;/span&gt;        &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;load&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="no"&gt;from&lt;/span&gt; &lt;span class="no"&gt;src&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vld4.8&lt;/span&gt;     &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;d4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d7&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;]!&lt;/span&gt;        &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;load&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="no"&gt;from&lt;/span&gt; &lt;span class="no"&gt;dst&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;subs&lt;/span&gt;       &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="c"&gt;#32                    \n&amp;quot;  // 32 processed per loop&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;vst4.8&lt;/span&gt;     &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;d0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d3&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]!&lt;/span&gt;        &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;store&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="no"&gt;to&lt;/span&gt; &lt;span class="no"&gt;dst&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;vst4.8&lt;/span&gt;     &lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="no"&gt;d4&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d5&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d6&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="no"&gt;d7&lt;/span&gt;&lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]!&lt;/span&gt;        &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;store&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="no"&gt;to&lt;/span&gt; &lt;span class="no"&gt;src&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;bgt&lt;/span&gt;        &lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="no"&gt;b&lt;/span&gt;                             &lt;span class="err"&gt;\&lt;/span&gt;&lt;span class="no"&gt;n&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;
      &lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;src&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;   &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;dst&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;   &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;srcdata&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;dstdata&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;
        &lt;span class="err"&gt;&amp;quot;+&lt;/span&gt;&lt;span class="nf"&gt;r&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="no"&gt;count&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="err"&gt;%&lt;/span&gt;&lt;span class="mi"&gt;4&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;Output&lt;/span&gt; &lt;span class="no"&gt;registers&lt;/span&gt;
      &lt;span class="err"&gt;:&lt;/span&gt;                     &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="nf"&gt;Input&lt;/span&gt; &lt;span class="no"&gt;registers&lt;/span&gt;
      &lt;span class="err"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="nf"&gt;cc&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;memory&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;q0&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;q1&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;q2&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt;&lt;span class="no"&gt;q3&lt;/span&gt;&lt;span class="err"&gt;&amp;quot;&lt;/span&gt;  &lt;span class="err"&gt;//&lt;/span&gt; &lt;span class="no"&gt;Clobber&lt;/span&gt; &lt;span class="no"&gt;List&lt;/span&gt;
    &lt;span class="err"&gt;)&lt;/span&gt;&lt;span class="c"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;同样，剩余的数据用纯C代码实现就好了， 在nexus6p上，这种镜像翻转一帧1080x1920 YUV数据大概只要不到&lt;strong&gt;5ms&lt;/strong&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;在编码好h264视频流之后，最终处理就是把音频流跟视频流合流然后包装到mp4文件，这部分我们可以通过系统的&lt;a href="https://developer.android.com/reference/android/media/MediaMuxer.html"&gt;MediaMuxer&lt;/a&gt;，&lt;a href="https://code.google.com/archive/p/mp4v2/"&gt;mp4v2&lt;/a&gt;，或者ffmpeg来实现，这部分比较简单，在这里就不再阐述了&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;注：本文亦被发表在《程序员》以及WeMobileDev公众号上&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/leixiaohua1020"&gt;雷霄骅(leixiaohua1020)的专栏&lt;/a&gt; ，大名鼎鼎雷神的博客，里面有非常多关于音视频编码/ffmpeg相关的学习资料，入门必备。也祝愿他能够在天堂安息吧&lt;/li&gt;
&lt;li&gt;&lt;a href="http://bigflake.com/mediacodec/"&gt;Android MediaCodec stuff&lt;/a&gt;，包含了一些MediaCodec使用的示例代码，初次使用可以参考下这里&lt;/li&gt;
&lt;li&gt;&lt;a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-1-load-and-stores"&gt;Coding for NEON&lt;/a&gt;，一个系列教程，讲述了一些常用Neon指令使用方法。上面在介绍缩放的时候使用到了Neon，事实上大部分音视频处理过程都会使用到，以YUV帧处理为例，缩放，旋转，镜像翻转都可以使用neon来做优化&lt;/li&gt;
&lt;li&gt;&lt;a href="https://chromium.googlesource.com/libyuv/libyuv/"&gt;libyuv&lt;/a&gt;，Google开源的一个YUV处理库，上面只针对1080p-&amp;gt;540p视频帧缩放的算法，而对于通用的压缩处理，可以直接使用这里的实现，对比起ffmpeg的速度快上不少&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>如何获取Android系统中申请对象的信息</title><link href="http://ragnraok.github.io/get_android_alloc_object_info.html" rel="alternate"></link><published>2016-05-30T00:00:00+08:00</published><updated>2016-05-30T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2016-05-30:/get_android_alloc_object_info.html</id><summary type="html">&lt;p&gt;最近一直在做有关内存方面的优化工作，在做优化的过程，除了关注内存的申请量以及GC的情况之外，我们经常需要想方法找出是那些对象占用了大量内存，以及他们是如何导致GC的，这意味着我们需要获取对象申请的信息（大小，类型，堆栈等），我们这篇文章来介绍下几种获取对象申请信息的方法&lt;/p&gt;
&lt;h3&gt;Allocation Tracker&lt;/h3&gt;
&lt;p&gt;Allocation Tracker是android studio自带的一个功能，我们可以在MemoryMonitor中打开使用：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/memorymonitor_1.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;如上图，点击红框按钮，然后操作app，开始allocation tracking，当认为需要结束的时候，再次点击按钮，稍等片刻，即可以在android studio中dump出在 &lt;strong&gt;这段时间&lt;/strong&gt; 内 &lt;strong&gt;新申请&lt;/strong&gt; 对象的信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/memorymonitor_2.png"&gt;&lt;/p&gt;
&lt;p&gt;这种使用方式相当直观，可以看到申请对象大小，数量，还有堆栈等，通过这些信息，我们可以作为我们接下来进行内存优化的参考&lt;/p&gt;
&lt;p&gt;但是，对于这种获取申请对象信息的方法，会存在几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取的信息过于分散，中间夹杂着不少其他的信息，不完全是app申请的，可能需要进行不少查找才能定位到具体的问题&lt;/li&gt;
&lt;li&gt;跟TraceView一样，无法做到自动化分析，每次都需要开发者手工开始/结束，对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难&lt;/li&gt;
&lt;li&gt;虽然在allocation …&lt;/li&gt;&lt;/ol&gt;</summary><content type="html">&lt;p&gt;最近一直在做有关内存方面的优化工作，在做优化的过程，除了关注内存的申请量以及GC的情况之外，我们经常需要想方法找出是那些对象占用了大量内存，以及他们是如何导致GC的，这意味着我们需要获取对象申请的信息（大小，类型，堆栈等），我们这篇文章来介绍下几种获取对象申请信息的方法&lt;/p&gt;
&lt;h3&gt;Allocation Tracker&lt;/h3&gt;
&lt;p&gt;Allocation Tracker是android studio自带的一个功能，我们可以在MemoryMonitor中打开使用：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/memorymonitor_1.jpeg"&gt;&lt;/p&gt;
&lt;p&gt;如上图，点击红框按钮，然后操作app，开始allocation tracking，当认为需要结束的时候，再次点击按钮，稍等片刻，即可以在android studio中dump出在 &lt;strong&gt;这段时间&lt;/strong&gt; 内 &lt;strong&gt;新申请&lt;/strong&gt; 对象的信息：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/memorymonitor_2.png"&gt;&lt;/p&gt;
&lt;p&gt;这种使用方式相当直观，可以看到申请对象大小，数量，还有堆栈等，通过这些信息，我们可以作为我们接下来进行内存优化的参考&lt;/p&gt;
&lt;p&gt;但是，对于这种获取申请对象信息的方法，会存在几个问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;获取的信息过于分散，中间夹杂着不少其他的信息，不完全是app申请的，可能需要进行不少查找才能定位到具体的问题&lt;/li&gt;
&lt;li&gt;跟TraceView一样，无法做到自动化分析，每次都需要开发者手工开始/结束，对于某些问题的分析可能会造成不便，而且对于批量分析来说也比较困难&lt;/li&gt;
&lt;li&gt;虽然在allocation tracking的时候，不会对手机本身的运行造成过多的性能影响，然而在停止allocation tracker的时候，直到把数据dump出来之前，会把手机完全卡死，时间过长甚至会直接ANR&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于这几个问题，特别是自动化分析来说，是否能够直接在代码上发起allocation tracker的请求并获得数据来分析呢？&lt;/p&gt;
&lt;h3&gt;在代码中发起allocation tracker请求&lt;/h3&gt;
&lt;p&gt;自然是可以的，不然为什么会有这个标题。。。&lt;/p&gt;
&lt;p&gt;我们可以把Android Studio的源码clone下来，在&lt;a href="http://tools.android.com/build"&gt;这里&lt;/a&gt;可以找到对应的git地址。在clone下来之后，我们可以在&lt;code&gt;./tools/adt/idea/android/src/com/android/tools/idea/ddms/actions/ToggleAllocationTrackingAction.java&lt;/code&gt;中看到android studio具体是如何发起和停止Allocation Tracker的：&lt;/p&gt;
&lt;p&gt;发起和停止：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClientData&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAllocationStatus&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; 
            &lt;span class="n"&gt;ClientData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;AllocationTrackingStatus&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ON&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;requestAllocationDetails&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
  &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;enableAllocationTracker&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myEvent&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Unexpected end of tracking, start now:&lt;/span&gt;
    &lt;span class="n"&gt;myEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;myEvents&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MemoryMonitorView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;EVENT_ALLOC&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;myEvent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;myEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
  &lt;span class="n"&gt;installListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;myProject&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;enableAllocationTracker&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myEvent&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// TODO add support for different end types (error, etc)&lt;/span&gt;
    &lt;span class="n"&gt;myEvent&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;stop&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
  &lt;span class="o"&gt;}&lt;/span&gt;
  &lt;span class="n"&gt;myEvent&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;myEvents&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;start&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;MemoryMonitorView&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;EVENT_ALLOC&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;requestAllocationStatus&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取并解析数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;AndroidDebugBridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addClientChangeListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;IClientChangeListener&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="nd"&gt;@Override&lt;/span&gt;
        &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;clientChanged&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Client&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;changeMask&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
          &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;listeningClient&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;changeMask&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;CHANGE_HEAP_ALLOCATIONS&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClientData&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAllocationsData&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

            &lt;span class="n"&gt;ApplicationManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getApplication&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;invokeLater&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Runnable&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
              &lt;span class="nd"&gt;@Override&lt;/span&gt;
              &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                  &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myProject&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isDisposed&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                    &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
                  &lt;span class="o"&gt;}&lt;/span&gt;

                  &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;CaptureService&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CaptureService&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getInstance&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;myProject&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                  &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSuggestedName&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;listeningClient&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                  &lt;span class="n"&gt;CaptureHandle&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;startCaptureFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AllocationCaptureType&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;class&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                  &lt;span class="n"&gt;service&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;appendDataCopy&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                  &lt;span class="o"&gt;.....&lt;/span&gt;
                    &lt;span class="c1"&gt;// Remove self from listeners.&lt;/span&gt;
                &lt;span class="n"&gt;AndroidDebugBridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;removeClientChangeListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
      &lt;span class="o"&gt;});&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出来这应该是一个异步的过程，在发起请求之后，系统会开始记录，然后再次发起停止请求之后，请求获得内存申请的数据（通过&lt;code&gt;c.requestAllocationDetails&lt;/code&gt;这一行），然后再预先注册好的&lt;code&gt;IClientChangeListener&lt;/code&gt;回调当中，获得数据已经准备好的通知，然后再获取数据，进行分析&lt;/p&gt;
&lt;p&gt;对于这里发起和停止Allocation的数据，以及注册的回调，大概涉及到了&lt;code&gt;Client&lt;/code&gt;，&lt;code&gt;AndroidDebugBridge&lt;/code&gt;，&lt;code&gt;IClientChangeListener&lt;/code&gt;等几个接口，这几个接口均不是Android Studio/IDEA中自带的类，而是在&lt;code&gt;ddmlib&lt;/code&gt;这个库中包含的，在android studio源码&lt;code&gt;/tools/base/ddmlib&lt;/code&gt;目录中有其源码，另外，在&lt;code&gt;/prebuilts/tools/common/offline-m2/com/android/tools/ddms/ddmlib&lt;/code&gt;目录中也有其预先build好的jar包。&lt;/p&gt;
&lt;p&gt;ddmlib这个库的作用，是用来建立电脑和android手机上连接的AndroidDebugBridge，然后让其对手机发起一些请求，例如刚才的AllocationTracker，还有dump hprof，traceview，甚至可以直接发送JdwpPacket，自定义PC和手机上的通讯（当然这个接口并非是开放的）。&lt;/p&gt;
&lt;p&gt;更重要的是，Google这个库是对外开放的，并且放到了maven当中，可以让开发者直接获取到这个库，不过似乎Google并没有大肆宣传这个，甚至连文档都没有。&lt;/p&gt;
&lt;p&gt;既然如此，我们也可以仿照上面的代码，用代码发起一次AllocationTracker请求，并进行分析：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;AndroidDebugBridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;init&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;AndroidDebugBridge&lt;/span&gt; &lt;span class="n"&gt;bridge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AndroidDebugBridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;createBridge&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;/path/to/your/adb/command&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
 &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="o"&gt;(!&lt;/span&gt;&lt;span class="n"&gt;bridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;isConnected&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;bridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;hasInitialDeviceList&lt;/span&gt;&lt;span class="o"&gt;())&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;sleep&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;200&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Exception&lt;/span&gt; &lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;e&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
 &lt;span class="o"&gt;}&lt;/span&gt;
 &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDevices&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;bridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDevices&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;length&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;IDevice&lt;/span&gt; &lt;span class="n"&gt;device&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;bridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getDevices&lt;/span&gt;&lt;span class="o"&gt;()[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;];&lt;/span&gt;
        &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;Client&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;device&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClient&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;com.example.ragnarok.allocrecordtest&amp;quot;&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;print&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;client: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;client&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;AndroidDebugBridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;addClientChangeListener&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;AndroidDebugBridge&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;IClientChangeListener&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
             &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;clientChanged&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Client&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;changeMask&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;((&lt;/span&gt;&lt;span class="n"&gt;changeMask&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;Client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;CHANGE_HEAP_ALLOCATIONS&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                            &lt;span class="n"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;println&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;clientChanged: &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;, &amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;changeMask&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                            &lt;span class="kt"&gt;byte&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;cl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getClientData&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;getAllocationsData&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
                            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                                &lt;span class="n"&gt;AllocationInfo&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;infoList&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;AllocationsParser&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;parse&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ByteBuffer&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;wrap&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
                            &lt;span class="o"&gt;}&lt;/span&gt;
                       &lt;span class="o"&gt;}&lt;/span&gt;
                    &lt;span class="o"&gt;}&lt;/span&gt;   
                &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;});&lt;/span&gt;
        &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;enableAllocationTracker&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;Timer&lt;/span&gt;&lt;span class="o"&gt;().&lt;/span&gt;&lt;span class="na"&gt;schedule&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;TimerTask&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                &lt;span class="nd"&gt;@Override&lt;/span&gt;
                &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;run&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;requestAllocationDetails&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
                    &lt;span class="n"&gt;client&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;enableAllocationTracker&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
                &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="o"&gt;},&lt;/span&gt; &lt;span class="mi"&gt;3000&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;代码比较长，我们主要做了这些操作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;初始化AndroidDebugBridge，并获取连接上的第一个设备对应的&lt;code&gt;IDevice&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;获取这个设备上"com.example.ragnarok.allocrecordtest"这个进程上对应的Client实例&lt;/li&gt;
&lt;li&gt;注册回调，并在回调中获取AllocationTracker回来的数据，并调用&lt;code&gt;AllocationParser&lt;/code&gt;进行解析&lt;/li&gt;
&lt;li&gt;发起和停止allocation tracker&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后在分析的时候，我们获得了一组&lt;code&gt;AllocationInfo&lt;/code&gt;，存储了申请对象的信息：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;AllocationInfo&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;mAllocatedClass&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mAllocNumber&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;mAllocationSize&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="kt"&gt;short&lt;/span&gt; &lt;span class="n"&gt;mThreadId&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="kd"&gt;final&lt;/span&gt; &lt;span class="n"&gt;StackTraceElement&lt;/span&gt;&lt;span class="o"&gt;[]&lt;/span&gt; &lt;span class="n"&gt;mStackTrace&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

   &lt;span class="o"&gt;.....&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;因为现在可以用代码发起Allocation Tracker请求了，那我们就可以接入自动化分析，并过滤掉我们不需要的数据。&lt;/p&gt;
&lt;p&gt;但是这样，也还是会有问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;这种方法会占用adb端口，这意味着可能在使用的时候，需要停止掉其他地方对adb的使用&lt;/li&gt;
&lt;li&gt;在停止allocation tracker之后，&lt;code&gt;requestAllocationDetails&lt;/code&gt;的调用还是会卡死手机，当然其实对于自动化分析来说，这里问题应该不大，但是对于使用者来说，还是造成了些许不爽&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对于上面的第二个问题，我们先来分析下android上的JVM是如何响应发过来的allocation tracker请求的&lt;/p&gt;
&lt;h3&gt;Android的JVM如何响应allocation tracker请求（Dalvik only now）&lt;/h3&gt;
&lt;p&gt;我们先来看下Dalvik虚拟机是怎么响应这个请求的，下面仅以4.4.4的代码为例&lt;/p&gt;
&lt;p&gt;首先，Dalvik虚拟机在收到Allocation Tracker的请求之后，在对JdwpPacket包进行解析之后，最后会在&lt;code&gt;DdmVmInternal&lt;/code&gt;这个类中进行处理，这个类在&lt;code&gt;/libcore/dalvik/src/main/java/org/apache/harmony/dalvik/ddmc/DdmVmInternal.java&lt;/code&gt;当中，其中有这么两个方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/**&lt;/span&gt;
&lt;span class="cm"&gt;* Enable or disable &amp;quot;recent allocation&amp;quot; tracking.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;enableRecentAllocations&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;* Return a boolean indicating whether or not the &amp;quot;recent allocation&amp;quot;&lt;/span&gt;
&lt;span class="cm"&gt;* feature is currently enabled.&lt;/span&gt;
&lt;span class="cm"&gt;*/&lt;/span&gt;
&lt;span class="kd"&gt;native&lt;/span&gt; &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;boolean&lt;/span&gt; &lt;span class="nf"&gt;getRecentAllocationStatus&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;很明显，这两个方法是用于开启和关闭Allocation Tracker，并且获得申请对象信息的数据的，然而是native的方法，对应的native代码在&lt;code&gt;/dalvik/vm/native/org_apache_harmony_dalvik_ddmc_DdmVmInternal.cpp&lt;/code&gt;这里：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * public static void enableRecentAllocations(boolean enable)&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Enable or disable recent allocation tracking.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Dalvik_org_apache_harmony_dalvik_ddmc_DdmVmInternal_enableRecentAllocations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;u4&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;JValue&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pResult&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;enable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;enable&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;dvmEnableAllocTracker&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;dvmDisableAllocTracker&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;RETURN_VOID&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * public static byte[] getRecentAllocations()&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Fill a buffer with data on recent heap allocations.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;Dalvik_org_apache_harmony_dalvik_ddmc_DdmVmInternal_getRecentAllocations&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;
    &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;u4&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;args&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;JValue&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pResult&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ArrayObject&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;data&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dvmDdmGetRecentAllocations&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;dvmReleaseTrackedAlloc&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;RETURN_PTR&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而&lt;code&gt;dvmEnableAllocTracker&lt;/code&gt;，&lt;code&gt;dvmDisableAllocTracker&lt;/code&gt;，&lt;code&gt;dvmDdmGetRecentAllocations&lt;/code&gt;这几个方法，经过几层的调用之后，最后是调用到了&lt;code&gt;/dalvik/vm/AllocTracker.cpp&lt;/code&gt;这里的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Enable allocation tracking.  Does nothing if tracking is already enabled.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Returns &amp;quot;true&amp;quot; on success.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;dvmEnableAllocTracker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;dvmLockMutex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordMax&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getAllocRecordMax&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;

        &lt;span class="n"&gt;ALOGI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Enabling alloc tracker (%d entries, %d frames --&amp;gt; %d bytes)&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordMax&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kMaxAllocRecordStackDepth&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
              &lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AllocRecord&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordMax&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordHead&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordCount&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AllocRecord&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;malloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;sizeof&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;AllocRecord&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordMax&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="n"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;false&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;dvmUnlockMutex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;result&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Disable allocation tracking.  Does nothing if tracking is not enabled.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;dvmDisableAllocTracker&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;dvmLockMutex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;dvmUnlockMutex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Generate a DDM packet with all of the tracked allocation data.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * On success, returns &amp;quot;true&amp;quot; with &amp;quot;*pData&amp;quot; and &amp;quot;*pDataLen&amp;quot; set.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;bool&lt;/span&gt; &lt;span class="nf"&gt;dvmGenerateTrackedAllocationReport&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;u1&lt;/span&gt;&lt;span class="o"&gt;**&lt;/span&gt; &lt;span class="n"&gt;pData&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pDataLen&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt; &lt;span class="p"&gt;....&lt;/span&gt; &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="c1"&gt;// 这个方法用于dump出gDvm.allocRecords中的数据&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;从上面的代码可以看出，在开启了Allocation Tracker之后，在Dalvik全局变量&lt;code&gt;gDvm&lt;/code&gt;下，将其中的&lt;code&gt;allocRecords&lt;/code&gt;指向了一块新的申请的内存区域，另外&lt;code&gt;allocRecordHead&lt;/code&gt;指向最新申请的对象信息的index，&lt;code&gt;allocRecordCount&lt;/code&gt;则是总的记录的数量，另外&lt;code&gt;allocRecordMax&lt;/code&gt;则是整个Allocation Tracker所允许记录的最大申请对象信息的数目，在4.4.4这个版本下，这个值默认是65536，也可以在手机中的/sytem/build.prop中指定&lt;code&gt;dalvik.vm.allocTrackerMax&lt;/code&gt;项的值。&lt;/p&gt;
&lt;p&gt;这里很明显看出来，&lt;code&gt;gDvm.allocRecords&lt;/code&gt;是用来记录新申请对象的信息的，而申请对象的时候，只要开启了Allocation Tracker，每次都会往这里添加一个记录，具体代码在这里：&lt;/p&gt;
&lt;p&gt;首先这里是新申请对象地方，在&lt;code&gt;/dalvik/vm/alloc/Alloc.cpp&lt;/code&gt;中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Create an instance of the specified class.&lt;/span&gt;
&lt;span class="cm"&gt; *&lt;/span&gt;
&lt;span class="cm"&gt; * Returns NULL and throws an exception on failure.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="nf"&gt;dvmAllocObject&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ClassObject&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;newObj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;....&lt;/span&gt;
    &lt;span class="cm"&gt;/* allocate on GC heap; memory is zeroed out */&lt;/span&gt;
    &lt;span class="n"&gt;newObj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;dvmMalloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;objectSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;flags&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newObj&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;DVM_OBJECT_INIT&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;newObj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="n"&gt;dvmTrackAllocation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;objectSize&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;   &lt;span class="cm"&gt;/* notify DDMS */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;newObj&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而在&lt;code&gt;dvmTrackAllocation&lt;/code&gt;方法，则是在&lt;code&gt;/vm/AllocTracker.h&lt;/code&gt;中定义：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * If allocation tracking is enabled, add a new entry to the set.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="cp"&gt;#define dvmTrackAllocation(_clazz, _size)                                   \&lt;/span&gt;
&lt;span class="cp"&gt;    {                                                                       \&lt;/span&gt;
&lt;span class="cp"&gt;        if (gDvm.allocRecords != NULL)                                      \&lt;/span&gt;
&lt;span class="cp"&gt;            dvmDoTrackAllocation(_clazz, _size);                            \&lt;/span&gt;
&lt;span class="cp"&gt;    }&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;dvmDoTrackAllocation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ClassObject&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// dvmDoTrackAllocation的定义在/dalvik/vm/AllocTracker.cpp当中&lt;/span&gt;
&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Add a new allocation to the set.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;dvmDoTrackAllocation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ClassObject&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;size_t&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Thread&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dvmThreadSelf&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;ALOGW&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;alloc tracker: no thread&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;dvmLockMutex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;dvmUnlockMutex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="cm"&gt;/* advance and clip */&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordHead&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordMax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordHead&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;AllocRecord&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;pRec&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecords&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordHead&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="n"&gt;pRec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;clazz&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pRec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;pRec&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;threadId&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="o"&gt;-&amp;gt;&lt;/span&gt;&lt;span class="n"&gt;threadId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;getStackFrames&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pRec&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordCount&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt; &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordMax&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocRecordCount&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;dvmUnlockMutex&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;分析到这里，Dalvik对Allocation Tracker的响应过程就非常清晰了：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在收到Allocation Tracker的请求的时候，首先给Dalvik全局变量&lt;code&gt;gDvm&lt;/code&gt;中的&lt;code&gt;allocRecords&lt;/code&gt;字段指向一段新申请的内存，申请内存的大小，由&lt;code&gt;gDvm.allocRecordMax&lt;/code&gt;指定&lt;/li&gt;
&lt;li&gt;后续Dalvik每次新申请对象的时候，只要&lt;code&gt;allocRecords&lt;/code&gt;不为NULL，那就会不断的往&lt;code&gt;allocRecords&lt;/code&gt;指向的内存区域中写入的新申请对象的信息，包括类型，大小，线程号，堆栈&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而&lt;code&gt;gDvm&lt;/code&gt;这个变量则具体是一个全局记录Dalvik虚拟机中状态的全局变量，定义和声明都在&lt;code&gt;/dalvik/vm/Globals.h&lt;/code&gt;中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DvmGlobals&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;....&lt;/span&gt;
    &lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt;     * Used for tracking allocations that we report to DDMS.  When the feature&lt;/span&gt;
&lt;span class="cm"&gt;     * is enabled (through a DDMS request) the &amp;quot;allocRecords&amp;quot; pointer becomes&lt;/span&gt;
&lt;span class="cm"&gt;     * non-NULL.&lt;/span&gt;
&lt;span class="cm"&gt;     */&lt;/span&gt;
    &lt;span class="n"&gt;pthread_mutex_t&lt;/span&gt; &lt;span class="n"&gt;allocTrackerLock&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;AllocRecord&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;    &lt;span class="n"&gt;allocRecords&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;             &lt;span class="n"&gt;allocRecordHead&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;        &lt;span class="cm"&gt;/* most-recently-added entry */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;             &lt;span class="n"&gt;allocRecordCount&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/* #of valid entries */&lt;/span&gt;
    &lt;span class="kt"&gt;int&lt;/span&gt;             &lt;span class="n"&gt;allocRecordMax&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* Number of allocated entries. */&lt;/span&gt;
&lt;span class="p"&gt;....&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;extern&lt;/span&gt; &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DvmGlobals&lt;/span&gt; &lt;span class="n"&gt;gDvm&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;而&lt;code&gt;AllocRecord&lt;/code&gt;的定义，则是在&lt;code&gt;/dalvik/vm/AllocTracker.cpp&lt;/code&gt; 中：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cm"&gt;/*&lt;/span&gt;
&lt;span class="cm"&gt; * Record the details of an allocation.&lt;/span&gt;
&lt;span class="cm"&gt; */&lt;/span&gt;
&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;AllocRecord&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ClassObject&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;    &lt;span class="n"&gt;clazz&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;      &lt;span class="cm"&gt;/* class allocated in this block */&lt;/span&gt;
    &lt;span class="n"&gt;u4&lt;/span&gt;              &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;       &lt;span class="cm"&gt;/* total size requested */&lt;/span&gt;
    &lt;span class="n"&gt;u2&lt;/span&gt;              &lt;span class="n"&gt;threadId&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* simple thread ID; could be recycled */&lt;/span&gt;

    &lt;span class="cm"&gt;/* stack trace elements; unused entries have method==NULL */&lt;/span&gt;
    &lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;Method&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;method&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;   &lt;span class="cm"&gt;/* which method we&amp;#39;re executing in */&lt;/span&gt;
        &lt;span class="kt"&gt;int&lt;/span&gt;         &lt;span class="n"&gt;pc&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;         &lt;span class="cm"&gt;/* current execution offset, in 16-bit units */&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;stackElem&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;kMaxAllocRecordStackDepth&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="cp"&gt;#define kMaxAllocRecordStackDepth   16      &lt;/span&gt;&lt;span class="cm"&gt;/* max 255 */&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出来这里拿到的信息，跟直接使用ddmlib的是一样的&lt;/p&gt;
&lt;p&gt;另外，可以看到&lt;code&gt;gDvm&lt;/code&gt;的声明是为&lt;code&gt;extern&lt;/code&gt;的，这意味着我们或许可以 &lt;strong&gt;直接&lt;/strong&gt; 获取到这个变量，一颗赛艇！&lt;/p&gt;
&lt;h4&gt;不影响手机本身性能的情况下获取申请对象信息&lt;/h4&gt;
&lt;p&gt;从上面的代码分析可以看到，类型为&lt;code&gt;DvmGlobals&lt;/code&gt;的&lt;code&gt;gDvm&lt;/code&gt;这个变量被声明成了extern，并且为非static变量，这意味在dalvik的so中，我们可以直接在符号表中获取到这个变量，简单来说，测试的代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="cp"&gt;#include&lt;/span&gt; &lt;span class="cpf"&gt;&amp;quot;Globals.h&amp;quot;&lt;/span&gt;&lt;span class="cp"&gt;&lt;/span&gt;
&lt;span class="p"&gt;....&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;dlopen&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;libdvm.so&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;RTLD_NOW&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;snprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buff&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;handle is 0x%x&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;LOGI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;%s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buff&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="n"&gt;t_gDvm&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;struct&lt;/span&gt; &lt;span class="n"&gt;DvmGlobals&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;dlsym&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;handle&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;&amp;quot;gDvm&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;t_gDvm&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;LOGI&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;get DvmGlobals&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="c1"&gt;// now t_gDvm-&amp;gt;allocRecords is the allocation record data&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面的&lt;code&gt;#include "Globals.h"&lt;/code&gt;是指Dalvik源码中的&lt;code&gt;Globals.h&lt;/code&gt;头文件， 另外这段Native的代码需要打包在某个app当中，然后在开启Allocation Tracker之后（之前介绍的随便一种方法都可以），运行这段代码，那么&lt;code&gt;t_gDvm-&amp;gt;allocRecords&lt;/code&gt;中就是申请对象的数据了，可以直接读取里面的字段，打印出来大概是这样的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/allocrecordjni.png"&gt;&lt;/p&gt;
&lt;p&gt;由于是直接读取Dalvik本身记录对象信息的结构，没有了结束Allocation Tracker时候把数据dump出来的请求，这意味着完全不会影响手机本身的性能，而且对于对象信息的获取，也能够更加的及时，例如说每隔10s把数据拿出来分析。相对来说，对于之前使用ddmlib的方案，10s定时请求这么高的频率，很有可能跑一会直接就把手机卡死了。&lt;/p&gt;
&lt;p&gt;但是对于这种方案，会存在兼容性问题，这里可以看到，我们获取&lt;code&gt;gDvm&lt;/code&gt;变量的方式是用&lt;code&gt;dlsym&lt;/code&gt;系统调用直接拿出来，然后强转成&lt;code&gt;DvmGlobals&lt;/code&gt;类型，然而由于不同版本的Dalvik虚拟机中的&lt;code&gt;DvmGlobals&lt;/code&gt;的定义不一样，可能会造成拿出&lt;code&gt;gDvm&lt;/code&gt;这个符号之后，对应的&lt;code&gt;allocRecords&lt;/code&gt;字段并不是真正的在这台机器上的&lt;code&gt;allocRecords&lt;/code&gt;字段，出现数据的错乱，或者&lt;code&gt;gDvm-&amp;gt;allocRecords&lt;/code&gt;压根为NULL 。就目前的简单测试来，暂时只有MX3 4.4.4系统的flyme os能够正常操作，估计这里要适配大部分机器的话，工作量应该不少。&lt;/p&gt;
&lt;h3&gt;Notes:&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;关于Allocation Tracker在JVM层的响应，目前暂时只有Dalvik的分析，而ART对Allocation Tracker的处理似乎更加复杂，尚在研究中&lt;/li&gt;
&lt;li&gt;这篇文章中的示例代码，可以从&lt;a href="https://github.com/ragnraok/AllocRecordDemo"&gt;这里&lt;/a&gt;拿到&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>Tricking Android MemoryFile</title><link href="http://ragnraok.github.io/tricking-android-memoryfile.html" rel="alternate"></link><published>2016-01-10T00:00:00+08:00</published><updated>2016-01-10T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2016-01-10:/tricking-android-memoryfile.html</id><summary type="html">&lt;p&gt;之前在做一个内存优化的时候，使用到了MemoryFile，由此发现了MemoryFile的一些特性以及一个非常trickly的使用方法，因此在这里记录一下&lt;/p&gt;
&lt;h3&gt;What is it&lt;/h3&gt;
&lt;p&gt;MemoryFile是android在最开始就引入的一套框架，其内部实际上是封装了android特有的内存共享机制&lt;a href="http://elinux.org/Android_Kernel_Features#ashmem"&gt;Ashmem&lt;/a&gt;匿名共享内存，简单来说，Ashmem在Android内核中是被注册成一个特殊的字符设备，Ashmem驱动通过在内核的一个自定义&lt;a href="https://en.wikipedia.org/wiki/Slab_allocation"&gt;slab&lt;/a&gt;缓冲区中初始化一段内存区域，然后通过mmap把申请的内存映射到用户的进程空间中（通过&lt;a href="https://en.wikipedia.org/wiki/Tmpfs"&gt;tmpfs&lt;/a&gt;），这样子就可以在用户进程中使用这里申请的内存了，另外，Ashmem的一个特性就是可以在系统内存不足的时候，回收掉被标记为"unpin"的内存，这个后面会讲到，另外，MemoryFile也可以通过Binder跨进程调用来让两个进程共享一段内存区域。由于整个申请内存的过程并不再Java层上，可以很明显的看出使用MemoryFile申请的内存实际上是&lt;strong&gt;并不会&lt;/strong&gt;占用Java堆内存的。&lt;/p&gt;
&lt;p&gt;MemoryFile暴露出来的用户接口可以说跟他的名字一样，基本上跟我们平时的文件的读写基本一致，也可以使用InputStream和OutputStream来对其进行读写等操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;MemoryFile&lt;/span&gt; &lt;span class="n"&gt;memoryFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MemoryFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inputStream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;available&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;memoryFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;allowPurging&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;OutputStream&lt;/span&gt; &lt;span class="n"&gt;outputStream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;memoryFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getOutputStream&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;outputStream …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;之前在做一个内存优化的时候，使用到了MemoryFile，由此发现了MemoryFile的一些特性以及一个非常trickly的使用方法，因此在这里记录一下&lt;/p&gt;
&lt;h3&gt;What is it&lt;/h3&gt;
&lt;p&gt;MemoryFile是android在最开始就引入的一套框架，其内部实际上是封装了android特有的内存共享机制&lt;a href="http://elinux.org/Android_Kernel_Features#ashmem"&gt;Ashmem&lt;/a&gt;匿名共享内存，简单来说，Ashmem在Android内核中是被注册成一个特殊的字符设备，Ashmem驱动通过在内核的一个自定义&lt;a href="https://en.wikipedia.org/wiki/Slab_allocation"&gt;slab&lt;/a&gt;缓冲区中初始化一段内存区域，然后通过mmap把申请的内存映射到用户的进程空间中（通过&lt;a href="https://en.wikipedia.org/wiki/Tmpfs"&gt;tmpfs&lt;/a&gt;），这样子就可以在用户进程中使用这里申请的内存了，另外，Ashmem的一个特性就是可以在系统内存不足的时候，回收掉被标记为"unpin"的内存，这个后面会讲到，另外，MemoryFile也可以通过Binder跨进程调用来让两个进程共享一段内存区域。由于整个申请内存的过程并不再Java层上，可以很明显的看出使用MemoryFile申请的内存实际上是&lt;strong&gt;并不会&lt;/strong&gt;占用Java堆内存的。&lt;/p&gt;
&lt;p&gt;MemoryFile暴露出来的用户接口可以说跟他的名字一样，基本上跟我们平时的文件的读写基本一致，也可以使用InputStream和OutputStream来对其进行读写等操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;MemoryFile&lt;/span&gt; &lt;span class="n"&gt;memoryFile&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MemoryFile&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;inputStream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;available&lt;/span&gt;&lt;span class="o"&gt;());&lt;/span&gt;
&lt;span class="n"&gt;memoryFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;allowPurging&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;false&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;OutputStream&lt;/span&gt; &lt;span class="n"&gt;outputStream&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;memoryFile&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getOutputStream&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
&lt;span class="n"&gt;outputStream&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;write&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1024&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面可以看到&lt;code&gt;allowPurging&lt;/code&gt;这个调用，这个就是之前说的"pin"和"unpin"，在设置了allowPurging为false之后，这个MemoryFile对应的Ashmem就会被标记成"pin"，那么即使在android系统内存不足的时候，也不会对这段内存进行回收。另外，由于Ashmem默认都是"unpin"的，因此申请的内存在某个时间点内都可能会被回收掉，这个时候是不可以再读写了&lt;/p&gt;
&lt;h3&gt;Tricks&lt;/h3&gt;
&lt;p&gt;MemoryFile是一个非常trickly的东西，由于并不占用Java堆内存，我们可以将一些对象用MemoryFile来保存起来避免GC，另外，这里可能android上有个BUG：&lt;/p&gt;
&lt;p&gt;在4.4及其以上的系统中，如果在应用中使用了MemoryFile，那么在dumpsys meminfo的时候，可以看到多了一项Ashmem的值：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/memoryfile_1.jpg"&gt;&lt;/p&gt;
&lt;p&gt;可以看出来虽然MemoryFile申请的内存不计入Java堆也不计入Native堆中，但是占用了Ashmem的内存，这个实际上是算入了app当前占用的内存当中&lt;/p&gt;
&lt;p&gt;但是在4.4以下的机器中时，使用MemoryFile申请的内存居然是&lt;strong&gt;不算入&lt;/strong&gt;app的内存中的：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/memoryfile_2.jpg"&gt;&lt;/p&gt;
&lt;p&gt;而且这里我也算过，也是不算入Native Heap中的，另外，这个时候去系统设置里面看进程的内存占用，也可以看出来其实并没有计入Ashmem的内存的&lt;/p&gt;
&lt;p&gt;这个应该是android的一个BUG，但是我搜了一下并没有搜到对应的issue，搞不好这里也可能是一个feature&lt;/p&gt;
&lt;p&gt;而在大名鼎鼎的Fresco当中，他们也有用到这个bug来避免在decode bitmap的时候，将文件的字节读到Java堆中，使用了MemoryFile，并利用了这个BUG然这部分内存不算入app中，这里分别对应了Fresco中的&lt;a href="https://github.com/facebook/fresco/blob/master/imagepipeline/src/main/java/com/facebook/imagepipeline/platform/GingerbreadPurgeableDecoder.java"&gt;GingerbreadPurgeableDecoder&lt;/a&gt;和&lt;a href="https://github.com/facebook/fresco/blob/master/imagepipeline/src/main/java/com/facebook/imagepipeline/platform/KitKatPurgeableDecoder.java"&gt;KitKatPurgeableDecoder&lt;/a&gt;，Fresco在decode图片的时候会在4.4和4.4以下的系统中分别使用这两个不同的decoder&lt;/p&gt;
&lt;p&gt;从这个地方可以看出来，使用MemoryFile，在4.4以下的系统当中，可以帮我们的app额外&lt;strong&gt;"偷"&lt;/strong&gt;一些内存，并且可以不计入app的内存当中&lt;/p&gt;
&lt;h3&gt;Summary&lt;/h3&gt;
&lt;p&gt;这里主要是简单介绍了MemoryFile的基本原理和用法，并且阐述了一个MemoryFile中一个可以帮助开发者"偷"内存的地方，这个是一个非常trickly的方法，虽然4.4以下使用这块的内存并不计入进程当中，但是并不推荐大量使用，因为当设置了allowPurging为false的时候，这个对应的Ashmem内存区域是被"pin"了，那么在android系统内存不足的时候，是不能够把这段内存区域回收的，如果长时间没有释放的话，这样子相当于无端端占用了大量手机内存而又无法回收，那对系统的稳定性肯定会造成影响&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href="http://blog.csdn.net/luoshengyang/article/details/6664554"&gt;Android系统匿名共享内存Ashmem（Anonymous Shared Memory）驱动程序源代码分析&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://elinux.org/Android_Kernel_Features#ashmem"&gt;Android Kernel Features(Ashmem)&lt;/a&gt;``&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>RxCamera, 一个RxJava风格的android camera封装</title><link href="http://ragnraok.github.io/rxcamera-introduce.html" rel="alternate"></link><published>2015-12-20T00:00:00+08:00</published><updated>2015-12-20T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2015-12-20:/rxcamera-introduce.html</id><summary type="html">&lt;p&gt;事实上这个库写了已经有一段时间了，由于最近工作上比较忙，所以现在才写一篇文章来总结&lt;/p&gt;
&lt;h3&gt;What's this&lt;/h3&gt;
&lt;p&gt;正如标题所说，&lt;a href="https://github.com/ragnraok/RxCamera"&gt;RxCamera&lt;/a&gt;是一个基于RxJava而构建的一套&lt;a href="http://developer.android.com/intl/es/reference/android/hardware/Camera.html"&gt;android.hardware.camera&lt;/a&gt;封装的库。最初写这个库的目的是为了熟悉RxJava，并且而且也看到虽然在android开发已经有不少基于RxJava的库，但是关于音视频相关却少之又少，于是就动手实现了一下。目前这个库还处于非常早期的状态，API比较简陋，并且关于camera的设置还有很多没有做&lt;/p&gt;
&lt;h3&gt;How to use&lt;/h3&gt;
&lt;p&gt;在&lt;a href="https://github.com/ragnraok/RxCamera"&gt;RxCamera&lt;/a&gt;的README中已经有关于这个库使用的比较详细介绍了，我在这里再说明一下：&lt;/p&gt;
&lt;h4&gt;加入依赖&lt;/h4&gt;
&lt;p&gt;首先你需要在项目中加入对RxCamera项目的依赖:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;repositories {
        jcenter()
}
dependencies {
    compile &amp;#39;com.ragnarok.rxcamera:lib:0.0.1&amp;#39;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;基本的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;配置camera的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;android的原生camera api提供了不少的选项来配置打开摄像头时候的参数，例如预览的帧率，预览的分辨率，自动对焦等，在RxCamera中主要是通过一个&lt;code&gt;RxCameraConfig&lt;/code&gt;对象来管理这些对象，并通过 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;事实上这个库写了已经有一段时间了，由于最近工作上比较忙，所以现在才写一篇文章来总结&lt;/p&gt;
&lt;h3&gt;What's this&lt;/h3&gt;
&lt;p&gt;正如标题所说，&lt;a href="https://github.com/ragnraok/RxCamera"&gt;RxCamera&lt;/a&gt;是一个基于RxJava而构建的一套&lt;a href="http://developer.android.com/intl/es/reference/android/hardware/Camera.html"&gt;android.hardware.camera&lt;/a&gt;封装的库。最初写这个库的目的是为了熟悉RxJava，并且而且也看到虽然在android开发已经有不少基于RxJava的库，但是关于音视频相关却少之又少，于是就动手实现了一下。目前这个库还处于非常早期的状态，API比较简陋，并且关于camera的设置还有很多没有做&lt;/p&gt;
&lt;h3&gt;How to use&lt;/h3&gt;
&lt;p&gt;在&lt;a href="https://github.com/ragnraok/RxCamera"&gt;RxCamera&lt;/a&gt;的README中已经有关于这个库使用的比较详细介绍了，我在这里再说明一下：&lt;/p&gt;
&lt;h4&gt;加入依赖&lt;/h4&gt;
&lt;p&gt;首先你需要在项目中加入对RxCamera项目的依赖:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;repositories {
        jcenter()
}
dependencies {
    compile &amp;#39;com.ragnarok.rxcamera:lib:0.0.1&amp;#39;
}
&lt;/pre&gt;&lt;/div&gt;


&lt;h4&gt;基本的使用&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;配置camera的参数&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;android的原生camera api提供了不少的选项来配置打开摄像头时候的参数，例如预览的帧率，预览的分辨率，自动对焦等，在RxCamera中主要是通过一个&lt;code&gt;RxCameraConfig&lt;/code&gt;对象来管理这些对象，并通过&lt;code&gt;RxCameraConfigChooser&lt;/code&gt;来配置对应参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    RxCameraConfig config = RxCameraConfigChooser.obtain().
        useBackCamera().
        setAutoFocus(true).
        setPreferPreviewFrameRate(15, 30).
        setPreferPreviewSize(new Point(640, 480)).
        setHandleSurfaceEvent(true).
        get();
&lt;/pre&gt;&lt;/div&gt;


&lt;ul&gt;
&lt;li&gt;打开摄像头并获取数据&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;在设置好参数之后，就可以直接打开摄像头了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    RxCamera.open(this, config).flatMap(new Func1&amp;lt;RxCamera, Observable&amp;lt;RxCamera&amp;gt;&amp;gt;() {
      @Override
      public Observable&amp;lt;RxCamera&amp;gt; call(RxCamera rxCamera) {
          return rxCamera.bindTexture(textureView);
          // or bind a SurfaceView:
          // rxCamera.bindSurface(SurfaceView)
      }
     }).flatMap(new Func1&amp;lt;RxCamera, Observable&amp;lt;RxCamera&amp;gt;&amp;gt;() {
        @Override
         public Observable&amp;lt;RxCamera&amp;gt; call(RxCamera rxCamera) {
            return rxCamera.startPreview();
         }
    });
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里包括了设置用于预览的Surface(这里是使用&lt;code&gt;TextureView&lt;/code&gt;进行预览)，然后正式开始预览。&lt;/p&gt;
&lt;p&gt;只有预览之后才能开始获取摄像头的数据：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;camera&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;request&lt;/span&gt;&lt;span class="o"&gt;()&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;periodicDataRequest&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;1000&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nc"&gt;subscribe&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;new&lt;/span&gt; &lt;span class="nt"&gt;Action1&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nt"&gt;RxCameraData&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="err"&gt;@Override&lt;/span&gt;
            &lt;span class="err"&gt;public&lt;/span&gt; &lt;span class="err"&gt;void&lt;/span&gt; &lt;span class="err"&gt;call(RxCameraData&lt;/span&gt; &lt;span class="err"&gt;rxCameraData)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;
                &lt;span class="err"&gt;showLog(&amp;quot;periodic&lt;/span&gt; &lt;span class="err"&gt;request,&lt;/span&gt; &lt;span class="err"&gt;cameraData.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;rxCameraData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;cameraData&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="err"&gt;}&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;获取摄像头的数据都通过&lt;code&gt;request&lt;/code&gt;来获取， RxCamera中封装了几种不同风格的cameraRequest，例如上面的是定时获取摄像头数据，每隔1000毫秒返回一次，另外还有连续返回数据，只返回一次数据等的request。这些request返回的Observable对象都会给订阅者返回&lt;code&gt;RxCameraData&lt;/code&gt;对象，其中包含两个字段&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;byte[] cameraData&lt;/code&gt;，就是原生的摄像头数据，具体的数据格式，如果是从预览数据中获取，则是设置的previewFormat格式，没有设置则默认为YUV12。如果是takePictureRequest的话，则是返回JPEG格式的数据&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;Matrix rotateMatrix&lt;/code&gt;，这个Matrix可以帮助你把返回的摄像头数据旋转回在竖屏模式下正常显示，因为大部分android手机的安装角度都会90度或者270度，这样子在横屏拍摄的时候可以拿到正确的图像，但是在竖屏显示的时候就会被旋转过来，使用这个Matrix旋转获取到的摄像头数据之后，就可以获取到正确转向的图像了&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;目前的状态&lt;/h3&gt;
&lt;p&gt;很明显这个库目前还处于非常早期的状态，API还比较简单，并且很多摄像头的参数也没有加入到进行设置，例如白平衡，闪光灯，测光等，后续这里将会逐渐完善丰富摄像头的各种设置。另外，由于是完全基于RxJava来构建的库，大部分接口都会直接返回Observable对象，这对于没有熟悉RxJava的人来说可能还是会有点距离，因此这里后续对接口的封装还是需要继续改进，对外可能不再暴露Observable对象&lt;/p&gt;
&lt;h3&gt;About camera2&lt;/h3&gt;
&lt;p&gt;熟悉android开发的人估计都已经知道在Lollipop，Google新增一套&lt;a href="http://developer.android.com/intl/es/reference/android/hardware/camera2/package-summary.html"&gt;camera2&lt;/a&gt;API用以取代之前的camera API，camera2提供了对摄像头更加精细化的控制，相对来说比起老的API，对摄像头的可控程度高了非常多。但我个人觉得新的API还不是特别好用，并且由于目前还是比较新，在使用新的camera2 API的时候，&lt;a href="http://source.android.com/devices/camera/versioning.html#camera_api2_capabilities_and_support_levels"&gt;还需要查询手机上有哪些特性是有实现的&lt;/a&gt;，目前使用起来相当麻烦。所以RxCamera暂时还不打算支持camera2&lt;/p&gt;</content></entry><entry><title>Project Lacie Initiate</title><link href="http://ragnraok.github.io/project-lacie-initiate.html" rel="alternate"></link><published>2015-08-17T00:00:00+08:00</published><updated>2015-08-17T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2015-08-17:/project-lacie-initiate.html</id><summary type="html">&lt;h3&gt;Motivation&lt;/h3&gt;
&lt;p&gt;我记得去年在组内介绍Annotation和&lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/"&gt;Annotation Process Tool&lt;/a&gt;的时候，当时不少小伙伴都认为这个是一个非常棒的工具，用来做代码生成非常合适，但是也存在不少问题，主要的争论点在于，对于大型的项目，其代码量非常大，无论是在IDE内或者在命令行中进行编译，即使只是普通的增量编译，打包，也需要耗上非常长的时间。而普通的APT则需要每次都先拉起一次编译过程，因为实际上整个Annotation Processing是Java编译中的一个&lt;a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html"&gt;步骤&lt;/a&gt;，另外如果在Annotation Processing的过程中另外产生了新的代码的话，还需要重新编译生成的代码，这会导致整个编译过程变得更加漫长，如下图，为Java源码编译的过程，摘自OpenJDK官网。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/javac-flow.png"&gt;&lt;/p&gt;
&lt;p&gt;于是，后续我就逐渐开始想方法实现有一个类似Annotation Processor的API的工具，但并不需要拉起Javac进行编译，只需要输入源码即可，然后由开发者自行定义生成代码的规则，即可完成APT的功能。&lt;/p&gt;
&lt;h3&gt;Research&lt;/h3&gt;
&lt;p&gt;要实现这样的一个工具，最先迫切的就是需要一个语法解析器，这样子才能从源码中提取出所需要的信息。当时候的想法是自己来实现Tokenizer和Parser（真庆幸大学的时候教编译原理的灭绝大法师的训练，我还记得怎么写哈哈哈哈），但很快我就找到了&lt;a href="https://javacc.java.net/"&gt;JavaCC&lt;/a&gt;这个工具，这玩意可以说是Java编译器的生成工具，实际上Javac的前端也是这个东西来生成的。但是JavaCC生成的代码非常乱并且其API并不是很好用。当时候我想当JDK中一定是有单独Javac前端独立出来的，于是我又找到了JDK中的&lt;code&gt;tools …&lt;/code&gt;&lt;/p&gt;</summary><content type="html">&lt;h3&gt;Motivation&lt;/h3&gt;
&lt;p&gt;我记得去年在组内介绍Annotation和&lt;a href="http://docs.oracle.com/javase/7/docs/technotes/guides/apt/"&gt;Annotation Process Tool&lt;/a&gt;的时候，当时不少小伙伴都认为这个是一个非常棒的工具，用来做代码生成非常合适，但是也存在不少问题，主要的争论点在于，对于大型的项目，其代码量非常大，无论是在IDE内或者在命令行中进行编译，即使只是普通的增量编译，打包，也需要耗上非常长的时间。而普通的APT则需要每次都先拉起一次编译过程，因为实际上整个Annotation Processing是Java编译中的一个&lt;a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html"&gt;步骤&lt;/a&gt;，另外如果在Annotation Processing的过程中另外产生了新的代码的话，还需要重新编译生成的代码，这会导致整个编译过程变得更加漫长，如下图，为Java源码编译的过程，摘自OpenJDK官网。&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/javac-flow.png"&gt;&lt;/p&gt;
&lt;p&gt;于是，后续我就逐渐开始想方法实现有一个类似Annotation Processor的API的工具，但并不需要拉起Javac进行编译，只需要输入源码即可，然后由开发者自行定义生成代码的规则，即可完成APT的功能。&lt;/p&gt;
&lt;h3&gt;Research&lt;/h3&gt;
&lt;p&gt;要实现这样的一个工具，最先迫切的就是需要一个语法解析器，这样子才能从源码中提取出所需要的信息。当时候的想法是自己来实现Tokenizer和Parser（真庆幸大学的时候教编译原理的灭绝大法师的训练，我还记得怎么写哈哈哈哈），但很快我就找到了&lt;a href="https://javacc.java.net/"&gt;JavaCC&lt;/a&gt;这个工具，这玩意可以说是Java编译器的生成工具，实际上Javac的前端也是这个东西来生成的。但是JavaCC生成的代码非常乱并且其API并不是很好用。当时候我想当JDK中一定是有单独Javac前端独立出来的，于是我又找到了JDK中的&lt;code&gt;tools.jar&lt;/code&gt;（OSX下这文件在&lt;code&gt;/Library/Java/JavaVirtualMachines/jdk_version/Contents/Home/lib&lt;/code&gt;可以找到），这玩意就是JDK的编译器前端，实现了Tokenizer和Parser，另外还实现了一套visitor模式的API，让使用者可以很方便的遍历整棵抽象语法树。这个库实在是太棒了，当时候就写了一篇&lt;a href="http://ragnraok.github.io/using-jdk-parser.html"&gt;文章&lt;/a&gt;来介绍这个库的使用。&lt;/p&gt;
&lt;h3&gt;Development&lt;/h3&gt;
&lt;p&gt;在了解了&lt;code&gt;tools.jar&lt;/code&gt;之后，我便开始了&lt;a href="https://github.com/ragnraok/JParserUtil"&gt;JParserUtil&lt;/a&gt;这个项目的开发，主要的目的在于利用&lt;code&gt;tools.jar&lt;/code&gt;，重新实现一套简单易用的API来获取源码的信息，例如类的名称，实现的接口信息，继承的类，包含了哪些方法，这些方法的名字，返回值，参数列表及其对应类型，类中变量的信息，名字，变量值的解析，变量的类型等。目前经过几个月的开发，基本上支持了以下的特性：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供了一套API来提取源码库的信息，只需要输入源码的根目录，就会遍历递归解析&lt;/li&gt;
&lt;li&gt;提取代码中所声明类、Annotation、接口、枚举的信息，名称，修饰符，实现的接口，继承的类等&lt;/li&gt;
&lt;li&gt;提取类中声明变量的信息，变量的类型（支持提取类型的全限定名），修饰符，值的解析等&lt;/li&gt;
&lt;li&gt;提取类中方法的信息，方法签名，返回值等&lt;/li&gt;
&lt;li&gt;通过输入source map（可以从这个&lt;a href="https://github.com/ragnraok/JavaSourceMapGenerator"&gt;项目&lt;/a&gt;中生成），支持从&lt;code&gt;import *&lt;/code&gt;获取类的全限定名&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;更具体的支持以及对应的TODO，可以看下这里的&lt;a href="https://github.com/ragnraok/JParserUtil"&gt;README&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;Another Beginning&lt;/h3&gt;
&lt;p&gt;目前&lt;a href="https://github.com/ragnraok/JParserUtil"&gt;JParserUtil&lt;/a&gt;项目已经大致完成，因此这个不用拉起编译期的Annotation Processor Tool项目也正式开始的，我将其命名为&lt;a href="https://github.com/ragnraok/Lacie"&gt;Projecct Lacie&lt;/a&gt;：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/lacie.jpg"&gt;&lt;/p&gt;
&lt;p&gt;至于Lacie是谁，可以参考下&lt;a href="http://baike.baidu.com/view/9817779.htm?fromtitle=%E8%95%BE%E8%A5%BF&amp;amp;fromid=13003855&amp;amp;type=syn"&gt;蕾西·巴斯卡比鲁&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;项目已经正式开始，正在处于快速的开发中，目前的road map大致如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;提供一套类似&lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/AbstractProcessor.html"&gt;AbstractProcessor&lt;/a&gt;以及对应的&lt;a href="http://docs.oracle.com/javase/7/docs/api/javax/annotation/processing/ProcessingEnvironment.html"&gt;ProcessingEnvironment&lt;/a&gt;，让开发者可以从原有的APT开发中顺利迁移过来。就目前来看，这套API并不算特别复杂，实现起来难度不大。&lt;/li&gt;
&lt;li&gt;由于JDK中ProcessingEnvironment的初始化是在编译过程中进行的，但我们这里并没有真正的拉起编译，因此还需要另外提供一套易用的接口来负责初始化整个环境。&lt;/li&gt;
&lt;li&gt;为了证明其可行性，打算另外实现一些使用APT编写的库，例如在android开发领域中大名鼎鼎的&lt;a href="https://github.com/excilys/androidannotations"&gt;AndroidAnnotations&lt;/a&gt;，&lt;a href="https://github.com/square/dagger"&gt;dagger&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;希望这个项目最后能被使用起来吧~，El Psy Congroo&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;OpenJDK主页关于Java源码编译过程的介绍：&lt;a href="http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html"&gt;http://openjdk.java.net/groups/compiler/doc/compilation-overview/index.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;JavaCC主页：&lt;a href="https://javacc.java.net/"&gt;https://javacc.java.net/&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;之前写关于&lt;code&gt;tools.jar&lt;/code&gt;的介绍：&lt;a href="http://ragnraok.github.io/using-jdk-parser.html"&gt;http://ragnraok.github.io/using-jdk-parser.html&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content></entry><entry><title>TextView预渲染研究</title><link href="http://ragnraok.github.io/textview-pre-render-research.html" rel="alternate"></link><published>2015-07-26T00:00:00+08:00</published><updated>2015-07-26T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2015-07-26:/textview-pre-render-research.html</id><summary type="html">&lt;p&gt;Android中的TextView是整个framework中最复杂的控件之一，负责Android中显示文本的大部分工作，framwork中的许多控件也直接或者间接的继承于TextView，例如Button，EditText等。其内部实现也相当复杂，单论代码行数来说，android-22中TextView有足足9509行，另外，TextView中许多操作都非常繁重，例如&lt;code&gt;setText&lt;/code&gt;操作，需要设置SpanWatcher，或者需要重现创建一个SpannableString，还需要根据情况重新创建Text Layout，这些操作加起来之后令一次setText操作非常耗时。为了提升TextView的渲染效率，最近研究了一下预渲染的方法，接下来给大家讲解一下原理。&lt;/p&gt;
&lt;h3&gt;TextView渲染基本原理&lt;/h3&gt;
&lt;p&gt;首先来介绍下TextView的基本渲染原理，总的来说，TextView中负责渲染文字的主要是这三个类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/BoringLayout.html"&gt;BoringLayout&lt;/a&gt; &lt;br /&gt;
    主要负责显示单行文本，并提供了isBoring方法来判断是否满足单行文本的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/DynamicLayout.html"&gt;DynamicLayout&lt;/a&gt; &lt;br /&gt;
    当文本为Spannable的时候，TextView就会使用它来负责文本的显示，在内部设置了SpanWatcher，当检测到span改变的时候，会进行reflow，重新计算布局。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/StaticLayout.html"&gt;StaticLayout&lt;/a&gt; &lt;br /&gt;
    当文本为非单行文本，且非Spannable的时候，就会使用StaticLayout，内部并不会监听span的变化，因此效率上会比DynamicLayout高，只需一次布局的创建即可，但其实内部也能显示SpannableString，只是不能在span变化之后重新进行布局而已。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，以上三个类都继承于&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/Layout.html"&gt;Layout&lt;/a&gt;类，在此类中统一负责文本的具体绘制，在Layout …&lt;/p&gt;</summary><content type="html">&lt;p&gt;Android中的TextView是整个framework中最复杂的控件之一，负责Android中显示文本的大部分工作，framwork中的许多控件也直接或者间接的继承于TextView，例如Button，EditText等。其内部实现也相当复杂，单论代码行数来说，android-22中TextView有足足9509行，另外，TextView中许多操作都非常繁重，例如&lt;code&gt;setText&lt;/code&gt;操作，需要设置SpanWatcher，或者需要重现创建一个SpannableString，还需要根据情况重新创建Text Layout，这些操作加起来之后令一次setText操作非常耗时。为了提升TextView的渲染效率，最近研究了一下预渲染的方法，接下来给大家讲解一下原理。&lt;/p&gt;
&lt;h3&gt;TextView渲染基本原理&lt;/h3&gt;
&lt;p&gt;首先来介绍下TextView的基本渲染原理，总的来说，TextView中负责渲染文字的主要是这三个类：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/BoringLayout.html"&gt;BoringLayout&lt;/a&gt; &lt;br /&gt;
    主要负责显示单行文本，并提供了isBoring方法来判断是否满足单行文本的条件。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/DynamicLayout.html"&gt;DynamicLayout&lt;/a&gt; &lt;br /&gt;
    当文本为Spannable的时候，TextView就会使用它来负责文本的显示，在内部设置了SpanWatcher，当检测到span改变的时候，会进行reflow，重新计算布局。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/StaticLayout.html"&gt;StaticLayout&lt;/a&gt; &lt;br /&gt;
    当文本为非单行文本，且非Spannable的时候，就会使用StaticLayout，内部并不会监听span的变化，因此效率上会比DynamicLayout高，只需一次布局的创建即可，但其实内部也能显示SpannableString，只是不能在span变化之后重新进行布局而已。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;另外，以上三个类都继承于&lt;a href="http://developer.android.com/intl/zh-cn/reference/android/text/Layout.html"&gt;Layout&lt;/a&gt;类，在此类中统一负责文本的具体绘制，在Layout.draw方法中，会对文本一行一行的进行渲染：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;TextLine&lt;/span&gt; &lt;span class="n"&gt;tl&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TextLine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;obtain&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;

&lt;span class="c1"&gt;// Draw the lines, one at a time.&lt;/span&gt;
&lt;span class="c1"&gt;// The baseline is the top of the following line minus the current line&amp;#39;s descent.&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;int&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;firstLine&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;lastLine&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;++)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
      &lt;span class="o"&gt;....&lt;/span&gt;
      &lt;span class="n"&gt;Directions&lt;/span&gt; &lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;getLineDirections&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;directions&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="n"&gt;DIRS_ALL_LEFT_TO_RIGHT&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;mSpannedText&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;hasTabOrEmoji&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
         &lt;span class="c1"&gt;// XXX: assumes there&amp;#39;s nothing additional to be done&lt;/span&gt;
          &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;drawText&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lbaseline&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;paint&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
          &lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;set&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;paint&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;buf&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;start&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;end&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;dir&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;directions&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hasTabOrEmoji&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;tabStops&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
          &lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ltop&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lbaseline&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;lbottom&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
      &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="n"&gt;TextLine&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;recycle&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tl&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出来对于Spannble，或者包含emoji的文本的话，实际渲染操作是交给了&lt;code&gt;TextLine&lt;/code&gt;去绘制，否则直接使用&lt;code&gt;canvas.drawText&lt;/code&gt;，&lt;code&gt;TextLine&lt;/code&gt;负责单行复杂文本的绘制，其中Spannable, Emoji之类的绘制逻辑都包含在里面，TextLine的绘制逻辑也并非十分高效，这里后续将会继续说明其应该如何优化。&lt;/p&gt;
&lt;h3&gt;TextLayoutCache&lt;/h3&gt;
&lt;p&gt;Canvas在&lt;code&gt;drawText&lt;/code&gt;的时候，如果需要每次都计算字体的大小，边距等之类的话，就会非常耗时，导致drawText时间会拉的很长，为了提高效率，android在4.0之后引入了TextLayoutCache，使用LRU Cache缓存了字形，边距等数据，提升了drawText的速度，在4.4中，这个cache的大小是0.5M，全局使用，并且会在Activity的&lt;code&gt;configurationChanged&lt;/code&gt;, &lt;code&gt;onResume&lt;/code&gt;, &lt;code&gt;lowMemory&lt;/code&gt;, &lt;code&gt;updateVisibility&lt;/code&gt;等时机，会调用&lt;code&gt;Canvas.freeTextLayoutCache&lt;/code&gt;来释放这部分内存。由于这部分的cache是系统底层控制的，我们无法做具体的控制。&lt;/p&gt;
&lt;h3&gt;TextView的预渲染优化&lt;/h3&gt;
&lt;p&gt;从TextView的渲染原理来看，如果只是单纯的显示文本，我们根本不需要另外设置SpanWatcher来监听span的变化，因此我们可以直接使用BoringLayout或者StaticLayout来直接显示文本内容，但是BoringLayout只能显示单行文本，因此这里最好的选择是直接用StaticLayout&lt;/p&gt;
&lt;p&gt;我们选择了自定义View，并希望最终有这样的一个接口：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kd"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;StaticLayoutView&lt;/span&gt; &lt;span class="kd"&gt;extends&lt;/span&gt; &lt;span class="n"&gt;View&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
    &lt;span class="kd"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Layout&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
    &lt;span class="kd"&gt;public&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;setLayout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Layout&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;requestLayout&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt; 
    &lt;span class="nd"&gt;@Override&lt;/span&gt;
    &lt;span class="kd"&gt;protected&lt;/span&gt; &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Canvas&lt;/span&gt; &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
        &lt;span class="kd"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;onDraw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;save&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt; &lt;span class="o"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;null&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
        &lt;span class="o"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;canvas&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;restore&lt;/span&gt;&lt;span class="o"&gt;();&lt;/span&gt;
    &lt;span class="o"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;我们可以直接通过设置这个view的Layout来绘制文本，并在&lt;code&gt;onDraw&lt;/code&gt;方法中直接使用这个Layout对象来绘制文本。在这里我们摒弃了&lt;code&gt;setText&lt;/code&gt;方法，直接通过Layout来绘制文本，而这里的Layout对象，我们可以通过预先创建之后才设置进去（这里可以放到单独的一个线程中创建），这样对比起普通TextView的&lt;code&gt;setText&lt;/code&gt;方法，我们减少了&lt;code&gt;setText&lt;/code&gt;中的许多消耗，可以大幅度的提升效率。&lt;/p&gt;
&lt;p&gt;StaticLayout的创建非常简单，只需要给定文本，宽度等就能直接创建。另外，为了预先填充TextLayoutCache，我们也可以在创建完StaticLayout对象之后，预先在一个dummy canvas中draw出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;StaticLayout&lt;/span&gt; &lt;span class="n"&gt;layout&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="n"&gt;StaticLayout&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;TestSpan&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;getSpanString&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="o"&gt;),&lt;/span&gt; &lt;span class="n"&gt;textPaint&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;hardCodeWidth&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;alignment&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;1.0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="mf"&gt;0f&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;layout&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;draw&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dummyCanvas&lt;/span&gt;&lt;span class="o"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;性能对比&lt;/h3&gt;
&lt;p&gt;接下来我们测试一下具体的性能，这里的testcase放到了Github上：&lt;a href="https://github.com/ragnraok/StaticLayoutView"&gt;StaticLayoutView&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;testcase的内容为，在一个ListView中，显示300个Item，每个item都是一段纯文本，里面全都是包含有大量ImageSpan的SpannableString，进行两边的对比，一边是直接使用StaticLayout，一边是使用普通的TextView，并且这300段文本不全相同，长度不同，随机生成，在StaticLayout的testcase中，StaticLayout都是预先在另外一个线程创建好之后才设置进去的，另外SpannableString也是预先生成好的。&lt;/p&gt;
&lt;p&gt;另外，在这里为了模拟真实app繁重的后台工作，另外创建了3个线程，不停在做浮点预算以尝试抢占CPU资源。&lt;/p&gt;
&lt;p&gt;测量性能的指标为，ListView连续向下滚动，测量其平均帧率为多少，分别测量五次，计算其平均值，最终性能测试结果如下：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/staticLayoutPerformance.png"&gt;&lt;/p&gt;
&lt;p&gt;这里测试的机器是MX3，左侧是直接使用StaticLayout的方案，右侧是系统的默认方案，Y轴是FPS，可以看出来，使用优化之后的方案，帧率提升了许多。&lt;/p&gt;
&lt;h3&gt;References&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://instagram-engineering.tumblr.com/post/114508858967/improving-comment-rendering-on-android"&gt;Improving Comment Rendering on Android&lt;/a&gt;   &lt;br /&gt;
这篇文章介绍了Instagram如何优化他们的TextView渲染的效率，这也是这里优化方法的来源，Instagram也是直接使用StaticLayout并通过预先创建Layout的方法来减少了ListView滚动过程中的掉帧率，并且效果非常显著。这篇文章算是给出了这里的原理解析以及一个简单的实现&lt;/p&gt;</content></entry><entry><title>使用Kotlin进行Android开发</title><link href="http://ragnraok.github.io/using-kotlin-to-write-android-app.html" rel="alternate"></link><published>2015-06-24T00:00:00+08:00</published><updated>2015-06-24T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2015-06-24:/using-kotlin-to-write-android-app.html</id><summary type="html">&lt;h3&gt;What is Kotlin&lt;/h3&gt;
&lt;p&gt;Kotlin，原意是在俄罗斯的一个&lt;a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%89%B9%E6%9E%97%E5%B3%B6"&gt;小岛&lt;/a&gt;，JetBrain在2011年推出了以这个来命名的一个运行在JVM上的语言， 看上去有点类似C#和Scala的结合，并且同为静态类型，作为一门JVM上的语言，可以轻松兼容Java，并且整个语言设计的非常轻量。目前的版本为&lt;code&gt;0.12.200&lt;/code&gt;，尚未发布正式版。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Kotlin的下载和配置在其&lt;a href="http://kotlinlang.org/docs/tutorials/getting-started.html"&gt;官网&lt;/a&gt;上有，在这里就不再赘述了，值得一提的是，作为JetBrains家出品的语言，自家的IDEA当然全力支持！&lt;/p&gt;
&lt;h3&gt;基本语法介绍&lt;/h3&gt;
&lt;p&gt;Kotlin的语法非常简洁，熟悉Java或者Scala的人都可以快速上手：&lt;/p&gt;
&lt;h4&gt;函数声明：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fun foo(va: Int): Int {
    return 1
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以单行声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fun foo(va: Int): Int = 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;lambda当然也是支持的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var c = {foo: Int -&amp;gt; println(foo …&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;h3&gt;What is Kotlin&lt;/h3&gt;
&lt;p&gt;Kotlin，原意是在俄罗斯的一个&lt;a href="https://zh.wikipedia.org/wiki/%E7%A7%91%E7%89%B9%E6%9E%97%E5%B3%B6"&gt;小岛&lt;/a&gt;，JetBrain在2011年推出了以这个来命名的一个运行在JVM上的语言， 看上去有点类似C#和Scala的结合，并且同为静态类型，作为一门JVM上的语言，可以轻松兼容Java，并且整个语言设计的非常轻量。目前的版本为&lt;code&gt;0.12.200&lt;/code&gt;，尚未发布正式版。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;Kotlin的下载和配置在其&lt;a href="http://kotlinlang.org/docs/tutorials/getting-started.html"&gt;官网&lt;/a&gt;上有，在这里就不再赘述了，值得一提的是，作为JetBrains家出品的语言，自家的IDEA当然全力支持！&lt;/p&gt;
&lt;h3&gt;基本语法介绍&lt;/h3&gt;
&lt;p&gt;Kotlin的语法非常简洁，熟悉Java或者Scala的人都可以快速上手：&lt;/p&gt;
&lt;h4&gt;函数声明：&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fun foo(va: Int): Int {
    return 1
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;也可以单行声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fun foo(va: Int): Int = 1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;lambda当然也是支持的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var c = {foo: Int -&amp;gt; println(foo)}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin中的函数是一等对象，自然支持高阶函数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var c = {foo: Int -&amp;gt; println(foo)}
fun fooTest(func: (Int)-&amp;gt;()) = println(&amp;quot;I&amp;#39;m Groot&amp;quot;)    
fooTest(c)
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;类与接口&lt;/h4&gt;
&lt;p&gt;类可以这样进行声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Bar&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;b&lt;/span&gt;: &lt;span class="kt"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;Foo() {&lt;/span&gt;
    &lt;span class="kd"&gt;var&lt;/span&gt; &lt;span class="nx"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt;
    &lt;span class="nx"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;class initializer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kr"&gt;constructor&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="k"&gt;this&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;secondary constructor&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Bar类在这里继承了Foo类，Bar类有两个构造函数，直接在Bar类头的是primary constructor，另外一个构造函数使用&lt;code&gt;constructor&lt;/code&gt;关键字定义，注意必须要先调用primary constructor，另外，&lt;code&gt;init&lt;/code&gt;标明的是class initializer，每个构造函数都会首先调用class initializer里面的代码，再调用构造函数&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Inner class:&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Outer&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;Inner&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;      
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin同样支持嵌套的内部类，不过和Java不一样的是，Kotlin的内部类不会默认包含一个指向外部类对象的引用，也就是说，Kotlin中所有的内部类默认就是&lt;strong&gt;静态&lt;/strong&gt;的，这样可以减少很多内存泄露的问题。另外，如果需要在内部类中引用外部类对象，可以在Inner类的声明前加上&lt;code&gt;inner&lt;/code&gt;关键字，然后在Inner类中使用标记的&lt;code&gt;this&lt;/code&gt;：&lt;code&gt;this@Outer&lt;/code&gt;来指向外部类对象&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Singleton:&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;object Single {
    var c = 1

    fun foo() = println(&amp;quot;foo&amp;quot;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin中使用&lt;code&gt;object&lt;/code&gt;关键字声明一个singleton对象，后面这里的方法就可以直接使用&lt;code&gt;Single.foo()&lt;/code&gt;来调用了&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Interface:&lt;/h5&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;interface&lt;/span&gt; &lt;span class="nx"&gt;Interface&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;fun&lt;/span&gt; &lt;span class="nx"&gt;foo() {&lt;/span&gt;
        &lt;span class="nx"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="nx"&gt;fun&lt;/span&gt; &lt;span class="nx"&gt;bar&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Kotlin中的interface，跟其他语言的&lt;code&gt;trait&lt;/code&gt;非常像，而且也可以带有默认的实现方法，并且不允许通过属性来维护状态。事实上，在上个版本中，interface的原来名称是&lt;code&gt;trait&lt;/code&gt;，而在M12现在这个版本中又改成了interface而已&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;Null safe and Smart type cast&lt;/h4&gt;
&lt;h5&gt;Null safe:&lt;/h5&gt;
&lt;p&gt;在Kotlin中，严格区分了nullable和非nullable对象，甚至在编译期解决了不少潜在的空指针问题:&lt;/p&gt;
&lt;p&gt;我们先来看下普通的变量声明&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var c: String = &amp;quot;12123&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里声明了一个String对象，其值为"12123"，我们可以正常的使用这个对象的成员方法：&lt;code&gt;c.length()&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;但是，如果在初始化的时候，变量c为空的话，这样声明就是错误的，会编译不过：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var c: String = null
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;正确的声明应该是这样：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var c: String? = null
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里在&lt;code&gt;String&lt;/code&gt;后面加多了一个问号，表明这里是一个&lt;strong&gt;Nullable&lt;/strong&gt;的对象，说明这个变量在使用的过程中&lt;strong&gt;可能为空&lt;/strong&gt;，而且，在调用这个变量的成员的时候，必须要使用这种语法：&lt;code&gt;c?.length()&lt;/code&gt;，在调用的时候添加了一个问号，表明，如果&lt;code&gt;c&lt;/code&gt;为空的时候，&lt;code&gt;length()&lt;/code&gt;这个方法就不会调用。coffe-script也有类似的，这种语法糖减少了很多平时用到的Null-checked，简化了代码，而且从编译器开始介入null-checked，大大减少了潜在的&lt;code&gt;NullPointerException&lt;/code&gt;，而事实上，null的确也是一个&lt;strong&gt;&lt;a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare"&gt;billion dollar mistake&lt;/a&gt;&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;常年进行如此的调用语法常常会很恼人，因此在你进行显式的Null-checked的时候，Kotlin的编译器会认为后续的调用已经无需进行Null-checked，可以直接调用了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (c != null) {
    c.length()
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h5&gt;Smart type cast&lt;/h5&gt;
&lt;p&gt;在Kotlin中，进行强制类型转换可以使用&lt;code&gt;as&lt;/code&gt;关键字，但有可能会抛出异常，因此，Kotlin引入了smart type cast:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;if (c is String) {
    c.length()
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;在上面的例子中，如果&lt;code&gt;c&lt;/code&gt;是一个String对象，则在if块中，可以直接使用String的方法，编译器会智能的帮你识别出c在if-blcok里面是一个String对象&lt;/p&gt;
&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;Pattern Matching&lt;/h4&gt;
&lt;p&gt;Kotlin在一定程度上支持了一些FP的特性，包括强大的Pattern Matching，在Kotlin中可以使用&lt;code&gt;when&lt;/code&gt;关键字：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;var x = 3
when (x) {
    1 -&amp;gt; print(&amp;quot;x == 1&amp;quot;)
    2 -&amp;gt; print(&amp;quot;x == 2&amp;quot;)
    in 1..10 -&amp;gt; print(&amp;quot;x is in the range&amp;quot;)
    !in 10..20 -&amp;gt; print(&amp;quot;x is outside the range&amp;quot;)
    is Int -&amp;gt; println(&amp;quot;is int&amp;quot;)
    else -&amp;gt; { // Note the block
      print(&amp;quot;x is neither 1 nor 2&amp;quot;)
    }
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;&lt;br /&gt;&lt;/p&gt;
&lt;h4&gt;Function Extension&lt;/h4&gt;
&lt;p&gt;在Java中我们经常需要给系统的类添加一些实用的方法，但苦于不能直接扩展，于是就有了各种的xxxUtils类，导致代码非常恶心，但是在Kotlin中，我们可以直接扩展库里面类的方法，通过function extension:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;fun String.fucker() {
    println(&amp;quot;a fucker&amp;quot;)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;上面给&lt;code&gt;String&lt;/code&gt;类添加了一个fucker方法，我们可以直接使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&amp;quot;123123&amp;quot;.fucker()
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这大大的减少了我们写xxxUtils类的必要性&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;配置使用Kotlin进行Android开发&lt;/h3&gt;
&lt;p&gt;使用Kotlin开发Android app的配置非常简单，按照&lt;a href="http://kotlinlang.org/docs/tutorials/kotlin-android.html"&gt;官方给出的配置即可&lt;/a&gt;，直接在Gradle的配置文件build.gradle中添加一个依赖：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;compile &amp;quot;org.jetbrains.kotlin:kotlin-stdlib:$kotlin_version&amp;quot;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;然后添加Kotlin插件的使用：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apply plugin: &amp;#39;kotlin-android&amp;#39;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;进行一次Gradle Sync之后，就可以直接在项目使用Kotlin编写代码了，另外，如果安装了Intellij的Kotlin插件，可以选择
&lt;code&gt;Tools-&amp;gt;Kotlin-&amp;gt;Configure Kotlin in Project&lt;/code&gt;，就可以自动进行上述的配置，一步到位&lt;/p&gt;
&lt;p&gt;我写了一个简单的Demo app放到了Github上，有兴趣可以看下使用Kotlin开发android app具体是怎样的：&lt;a href="https://github.com/ragnraok/MovieCamera"&gt;Demo地址&lt;/a&gt;&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;对于dex方法数目的影响&lt;/h3&gt;
&lt;p&gt;dex有个65535方法数的限制，这对Android开发造成了很大的影响，在使用Kotlin进行android app开发的时候，需要将Kotlin的标准库打包进入apk中，这意味着如果标准库过大，对分包会造成很大的限制（因为这必须得打包在主dex中），所幸的是，Kotlin的哲学是“Java中有的，就尽量复用，不再自行创造一套”，使得整个Kotlin的标准库非常小，我们可以简单将Kotlin的标准库和其他比较常用库进行一下对比：&lt;/p&gt;
&lt;table border="1" cellpadding="5"&gt;
    &lt;tr&gt;
        &lt;td&gt; 包名&lt;/td&gt;
        &lt;td&gt;android-support-v13.jar&lt;/td&gt;
        &lt;td&gt;android-support-v4.jar&lt;/td&gt;
        &lt;td&gt;android-support-v7-appcompat.jar&lt;/td&gt;
        &lt;td&gt;guava-18.0.jar&lt;/td&gt;
        &lt;td&gt;scala-library-2.12.0-M1.jar&lt;/td&gt;
        &lt;td&gt;kotlin-stdlib-0.12.213.jar&lt;/td&gt;
    &lt;/tr&gt;
    &lt;tr&gt;
        &lt;td&gt;方法数&lt;/td&gt;
        &lt;td&gt;8219&lt;/td&gt;
        &lt;td&gt;8118&lt;/td&gt;
        &lt;td&gt;4624&lt;/td&gt;
        &lt;td&gt;14833&lt;/td&gt;
        &lt;td&gt;51248&lt;/td&gt;
        &lt;td&gt;7228&lt;/td&gt;
    &lt;/tr&gt;
&lt;/table&gt;

&lt;p&gt;&lt;br /&gt;
可以看出来Kotlin的标准库相当小，只有7000多个方法，比support-v13和support-v4还小，这体现了Kotlin的设计哲学之一："100% interoperable with Java"，基本上Java已经有的，Kotlin会尽量复用。而对比来看，同样是JVM上的语言，我们也可以选择使用Scala来进行Android开发，但Scala标准库有5万多个方法，全部打包进主dex中，很容易就导致app爆主dex了。所以综合来看，轻量形的Kotlin还是相当适合进行Android开发的。&lt;/p&gt;
&lt;hr&gt;
&lt;h3&gt;Project Anko&lt;/h3&gt;
&lt;p&gt;&lt;a href="https://github.com/JetBrains/anko"&gt;Anko&lt;/a&gt; 是JetBrains推出的一个简化Android开发的库，同样由Kotlin来编写，主要的革命在于，声明UI的方式，完全抛弃了xml的使用，使用Anko，声明UI是这样做的：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;override fun onCreate(savedInstanceState: Bundle?) {
    super.onCreate(savedInstanceState)
    val customStyle = { v: Any -&amp;gt;
        when (v) {
            is Button -&amp;gt; v.textSize = 26f
            is EditText -&amp;gt; v.textSize = 24f
        }
    }

    verticalLayout {

        padding = dip(34)
        imageView(android.R.drawable.ic_menu_manage).layoutParams {
            margin = dip(16)
            gravity = Gravity.CENTER
        }

         val name = editText {
             hintResource = R.string.name
        }
        val password = editText {
            hintResource = R.string.password
            inputType = TYPE_CLASS_TEXT or TYPE_TEXT_VARIATION_PASSWORD
        }

        button(&amp;quot;Log in&amp;quot;) {
            onClick {
                tryLogin(name.text, password.text)
            }
        }
    }.style(customStyle)
}
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;你没看错，的确是在Activity类的onCreate方法中直接声明UI的布局。&lt;/p&gt;
&lt;p&gt;Anko看起来像是使用了一种类似DSL的方式声明了界面的UI，这里主要是使用了Kotlin的其中两个特性：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Function Extension，Anko扩展了Activity类，提供了额外的方法和属性&lt;/li&gt;
&lt;li&gt;Kotlin在调用函数的时候，如果最后一个参数为函数的话，则可以直接使用Lambda，并省略括号&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此这里声明布局的方式，其实全是Kotlin的原生代码，鹅妹子嘤！这样做有显然的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;由于实际上全是由代码来布局，省去了解析xml的时间&lt;/li&gt;
&lt;li&gt;xml本身有许多缺点，例如不可重用，非类型安全等，使用代码布局的话，我们可以很容易的就解决这个问题了&lt;/li&gt;
&lt;/ul&gt;
&lt;hr&gt;
&lt;h3&gt;Other References:&lt;/h3&gt;
&lt;p&gt;这里列出一些国外的关于Kotlin的介绍文章：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://docs.google.com/document/d/1ReS3ep-hjxWA8kZi0YqDbEhCqTt29hG8P44aA9W0DM8/edit?hl=zh-CN&amp;amp;forcehl=1"&gt;Using Project Kotlin for Android&lt;/a&gt; Square的JakeWharton曾经考察过几种不同的语言来进行Android开发，最后还是认为Kotlin比较优秀&lt;/li&gt;
&lt;li&gt;&lt;a href="http://blog.gouline.net/2014/08/31/kotlin-the-swift-of-android/"&gt;Kotlin, the Swift of Android&lt;/a&gt; 这篇文章把Kotlin比喻为Android上的swift，虽然比较老，但是也可以看做Kotlin的介绍性文章&lt;/li&gt;
&lt;/ul&gt;</content></entry><entry><title>使用JDK的Parser来解析Java源代码</title><link href="http://ragnraok.github.io/using-jdk-parser.html" rel="alternate"></link><published>2015-04-12T00:00:00+08:00</published><updated>2015-04-12T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2015-04-12:/using-jdk-parser.html</id><summary type="html">&lt;p&gt;在JDK中，自带了一套相关的编译API，可以在Java中发起编译流程，解析Java源文件然后获取其语法树，在JDK的&lt;code&gt;tools.jar&lt;/code&gt;（OSX下可以在/Library/Java/JavaVirtualMachines/jdk_version/Contents/Home/lib中找到）中包含着这整套API，但是这却不是Oracle和OpenJDK发布中的公开API，因此对于这套API，并没有官方的正式文档来进行说明。但是，也有不少项目利用了这套API来做了不少事情，例如大名鼎鼎的&lt;a href="https://github.com/rzwitserloot/lombok.git"&gt;lombok&lt;/a&gt;使用了这套API在Annotation Processing阶段修改了源代码中的语法树，最终结果相当于直接在源文件中插入了新的代码！&lt;/p&gt;
&lt;p&gt;由于这套API目前缺少相关文档，使用起来比较困难，例如，解析源代码中的所有变量，并打印出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="kr"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;final&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="nx"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;User.java&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;JavacFileManager&lt;/span&gt; &lt;span class="nx"&gt;fileManager&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;JavacTool&lt;/span&gt; &lt;span class="nx"&gt;javacTool&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Context …&lt;/span&gt;&lt;/pre&gt;&lt;/div&gt;</summary><content type="html">&lt;p&gt;在JDK中，自带了一套相关的编译API，可以在Java中发起编译流程，解析Java源文件然后获取其语法树，在JDK的&lt;code&gt;tools.jar&lt;/code&gt;（OSX下可以在/Library/Java/JavaVirtualMachines/jdk_version/Contents/Home/lib中找到）中包含着这整套API，但是这却不是Oracle和OpenJDK发布中的公开API，因此对于这套API，并没有官方的正式文档来进行说明。但是，也有不少项目利用了这套API来做了不少事情，例如大名鼎鼎的&lt;a href="https://github.com/rzwitserloot/lombok.git"&gt;lombok&lt;/a&gt;使用了这套API在Annotation Processing阶段修改了源代码中的语法树，最终结果相当于直接在源文件中插入了新的代码！&lt;/p&gt;
&lt;p&gt;由于这套API目前缺少相关文档，使用起来比较困难，例如，解析源代码中的所有变量，并打印出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="kr"&gt;static&lt;/span&gt; &lt;span class="kr"&gt;final&lt;/span&gt; &lt;span class="nb"&gt;String&lt;/span&gt; &lt;span class="nx"&gt;path&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;User.java&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;JavacFileManager&lt;/span&gt; &lt;span class="nx"&gt;fileManager&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="kr"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;JavacTool&lt;/span&gt; &lt;span class="nx"&gt;javacTool&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Context&lt;/span&gt; &lt;span class="nx"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;Context&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="nx"&gt;fileManager&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;JavacFileManager&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kc"&gt;true&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Charset&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;defaultCharset&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
        &lt;span class="nx"&gt;javacTool&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;JavacTool&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="k"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;parseJavaFiles&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;JavaFileObject&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;fileManager&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getJavaFileObjects&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;path&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="nx"&gt;JavaCompiler&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;CompilationTask&lt;/span&gt; &lt;span class="nx"&gt;compilationTask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;javacTool&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getTask&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;fileManager&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;files&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="nx"&gt;JavacTask&lt;/span&gt; &lt;span class="nx"&gt;javacTask&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;JavacTask&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;compilationTask&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;try&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;Iterable&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;CompilationUnitTree&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;javacTask&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parse&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;CompilationUnitTree&lt;/span&gt; &lt;span class="nx"&gt;tree&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;result&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;tree&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;accept&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;SourceVisitor&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;catch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;IOException&lt;/span&gt; &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;e&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;printStackTrace&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;SourceVisitor&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;TreeScanner&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="nx"&gt;Void&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="k"&gt;private&lt;/span&gt; &lt;span class="nx"&gt;String&lt;/span&gt; &lt;span class="nx"&gt;currentPackageName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;Override&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;visitCompilationUnit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;CompilationUnitTree&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;        
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;visitCompilationUnit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;Override&lt;/span&gt;
        &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;visitVariable&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;VariableTree&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;variable name: %s, type: %s, kind: %s, package: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; 
                    &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getType&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getKind&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;currentPackageName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="k"&gt;null&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="nx"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt; &lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Object&lt;/span&gt;&lt;span class="o"&gt;...&lt;/span&gt; &lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nx"&gt;System&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;out&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;println&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;format&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;public&lt;/span&gt; &lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="nx"&gt;void&lt;/span&gt; &lt;span class="nx"&gt;main&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;String&lt;/span&gt;&lt;span class="p"&gt;[]&lt;/span&gt; &lt;span class="nx"&gt;args&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="k"&gt;new&lt;/span&gt; &lt;span class="nx"&gt;JavaParser&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;parseJavaFiles&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中 &lt;code&gt;User.java&lt;/code&gt;的代码如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;package&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;ragnarok&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;javaparser&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;com.sun.istack.internal.Nullable&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="nn"&gt;java.lang.Override&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;User&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="nd"&gt;@Nullable&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;123123&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;UserMethod&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;

    &lt;span class="n"&gt;static&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Foo&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;private&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt; &lt;span class="n"&gt;fooString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;123123&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;public&lt;/span&gt; &lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;FooMethod&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;执行上面的&lt;code&gt;JavaParser&lt;/code&gt;结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="n"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;annotaion&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Nullable&lt;/span&gt;
&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;foo&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;VARIABLE&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;package&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ragnarok&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;javaparser&lt;/span&gt;
&lt;span class="n"&gt;variable&lt;/span&gt; &lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;a&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;type&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Foo&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;kind&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;VARIABLE&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="kd"&gt;package&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;com&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;ragnarok&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="na"&gt;javaparser&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里我们是首先通过&lt;code&gt;JavaCompiler.CompilationTask&lt;/code&gt;解析了源文件之后，再使用自定义的&lt;code&gt;SourceVisitor&lt;/code&gt;（继承自&lt;code&gt;TreeScanner&lt;/code&gt;）来对源代码的结构进行访问，在&lt;code&gt;SourceVisitor&lt;/code&gt;类中，通过重载&lt;code&gt;visitVariable&lt;/code&gt;来对一个编译单元（单个源代码文件）进行解析，访问其中的所有的变量，这里可以看出，我们没有办法拿到这个变量类型的全限定名（包含包名），只能拿到的对应的简单名字，因此，类型的确定需要外部实现&lt;strong&gt;自行确定&lt;/strong&gt;，例如可以通过记录类所在的包名，递归的搜索整个源代码目录来跟踪所有类的全限定名，查找import中是否包含对应的类型等。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;TreeScanner&lt;/code&gt;中除了&lt;code&gt;visitVariable&lt;/code&gt;方法外，还包含了大量其他的&lt;code&gt;visitXYZ&lt;/code&gt;方法，例如，可以遍历所有的import，方法定义，Annotation等，更具体可以查看OpenJDK中关于这个的源代码&lt;/p&gt;
&lt;p&gt;这里再来看下另外一个例子，重载&lt;code&gt;visitClass&lt;/code&gt;方法，访问所有的内部类以及类本身：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="nx"&gt;Override&lt;/span&gt;
&lt;span class="kr"&gt;public&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;visitClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;ClassTree&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;Void&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;class name: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getSimpleName&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;Tree&lt;/span&gt; &lt;span class="nx"&gt;member&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getMembers&lt;/span&gt;&lt;span class="p"&gt;())&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;member&lt;/span&gt; &lt;span class="k"&gt;instanceof&lt;/span&gt; &lt;span class="nx"&gt;VariableTree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nx"&gt;VariableTree&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;VariableTree&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nx"&gt;member&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="nx"&gt;List&lt;/span&gt;&lt;span class="cp"&gt;&amp;lt;?&lt;/span&gt; &lt;span class="k"&gt;extends&lt;/span&gt; &lt;span class="nx"&gt;AnnotationTree&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="nx"&gt;annotations&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getModifiers&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getAnnotations&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;annotations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;size&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;variable: %s, annotaion: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="nx"&gt;annotations&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;get&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getAnnotationType&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="nx"&gt;formatPtrln&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;variable: %s&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;variable&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;getName&lt;/span&gt;&lt;span class="p"&gt;());&lt;/span&gt;
            &lt;span class="p"&gt;}&lt;/span&gt;                
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nx"&gt;super&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="nx"&gt;visitClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;node&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;aVoid&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;这里简单的打印了类名以及变量的名称，类型，annotation类型，执行上面的代码，结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;: &lt;span class="kt"&gt;User&lt;/span&gt;
&lt;span class="nx"&gt;variable&lt;/span&gt;: &lt;span class="kt"&gt;foo&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nx"&gt;annotaion&lt;/span&gt;: &lt;span class="kt"&gt;Nullable&lt;/span&gt;
&lt;span class="nx"&gt;variable&lt;/span&gt;: &lt;span class="kt"&gt;a&lt;/span&gt;
&lt;span class="kr"&gt;class&lt;/span&gt; &lt;span class="nx"&gt;name&lt;/span&gt;: &lt;span class="kt"&gt;Foo&lt;/span&gt;
&lt;span class="nx"&gt;variable&lt;/span&gt;: &lt;span class="kt"&gt;fooString&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;可以看出我们把类名以及类中的变量都打印了出来。而在&lt;code&gt;visitClass&lt;/code&gt;方法中，我们可以通过&lt;code&gt;getMembers&lt;/code&gt;方法拿到类中所有的成员，包括变量，方法，annotation等，分别对应着不同的类型，例如变量就对应着&lt;code&gt;VariableTree&lt;/code&gt;类型，方法就对应的&lt;code&gt;MethodTree&lt;/code&gt;类型。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;总得来说，虽然实际上使用并不算特别复杂，但是由于缺少文档，对使用造成了很大的障碍，而且目前所介绍的只是这套API的一少部分，后续我将会继续研究这套API的相关函数。&lt;/p&gt;</content></entry><entry><title>探索在Android中使用Emoji Font的方法</title><link href="http://ragnraok.github.io/android-emoji-font-method.html" rel="alternate"></link><published>2015-01-14T00:00:00+08:00</published><updated>2015-01-14T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2015-01-14:/android-emoji-font-method.html</id><summary type="html">&lt;p&gt;先说结论，在android4.4以前，无法使用像苹果那样的emoji字体样式，最简单的解决方案是使用ImageSpan配合SpannableString，而在4.4及之后的版本，则可以直接采用类似iOS/OSX的方案进行快速渲染。&lt;/p&gt;
&lt;h3&gt;Apple Color Emoji&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E7%B9%AA%E6%96%87%E5%AD%97"&gt;Emoji&lt;/a&gt;表情，最初是从日本的“绘文字”演化过来，在没有正式定下规范之前，日本的三大电信运营商，NTT DoCoMo，au/KDDI，Softbank都各自有一套关于Emoji的编码规范，而且在这个时候，每个Emoji表情对应的表情图片也是没有统一规范的。这时候，应用最广泛的是应该的属于日本软银（Softbank）的Softbank编码了，在iOS系统的早期的版本上，采用的也是这个编码规范。&lt;/p&gt;
&lt;p&gt;后来，在2010年10月，随着Unicode6.0的发布，Emoji的编码以及对应的表情图片正式被规范化，核心Emoji表情包含722个Emoji编码。而到了Unicode 7.0（2014年6月发行）之后，更多的Emoji表情被加入了进来，包括一些其他比较偏门的Emoji表情组，例如&lt;a href="http://en.wikipedia.org/wiki/Webdings"&gt;Webdings&lt;/a&gt;，&lt;a href="http://en.wikipedia.org/wiki/Wingdings"&gt;Wingdings&lt;/a&gt;，也被编入了Unicode 7 …&lt;/p&gt;</summary><content type="html">&lt;p&gt;先说结论，在android4.4以前，无法使用像苹果那样的emoji字体样式，最简单的解决方案是使用ImageSpan配合SpannableString，而在4.4及之后的版本，则可以直接采用类似iOS/OSX的方案进行快速渲染。&lt;/p&gt;
&lt;h3&gt;Apple Color Emoji&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://zh.wikipedia.org/wiki/%E7%B9%AA%E6%96%87%E5%AD%97"&gt;Emoji&lt;/a&gt;表情，最初是从日本的“绘文字”演化过来，在没有正式定下规范之前，日本的三大电信运营商，NTT DoCoMo，au/KDDI，Softbank都各自有一套关于Emoji的编码规范，而且在这个时候，每个Emoji表情对应的表情图片也是没有统一规范的。这时候，应用最广泛的是应该的属于日本软银（Softbank）的Softbank编码了，在iOS系统的早期的版本上，采用的也是这个编码规范。&lt;/p&gt;
&lt;p&gt;后来，在2010年10月，随着Unicode6.0的发布，Emoji的编码以及对应的表情图片正式被规范化，核心Emoji表情包含722个Emoji编码。而到了Unicode 7.0（2014年6月发行）之后，更多的Emoji表情被加入了进来，包括一些其他比较偏门的Emoji表情组，例如&lt;a href="http://en.wikipedia.org/wiki/Webdings"&gt;Webdings&lt;/a&gt;，&lt;a href="http://en.wikipedia.org/wiki/Wingdings"&gt;Wingdings&lt;/a&gt;，也被编入了Unicode 7.0规范，此时，整个Emoji编码集合已经有大概1000个左右，而在表情图片的规范上，除了我们常见的ios style之外，还有Android Style，Twitter Style等，在&lt;a href="http://apps.timwhitlock.info/emoji/tables/unicode"&gt;这里&lt;/a&gt;，有一份比较详细的Emoji表情列表，包含了不同的表情样式以及对应的编码。&lt;/p&gt;
&lt;p&gt;而在iOS系统上，在Unicode 6.0规范出来之前，原来也是采用Softbank编码（iOS 4以及之前版本），而Unicode 6.0规范之后（iOS 5以及之后的版本，或者OSX Lion之后的系统），则改为使用了Unicode编码。&lt;/p&gt;
&lt;p&gt;那么，iOS/OSX是怎么把这些Emoji表情渲染出来的呢？&lt;/p&gt;
&lt;p&gt;在OSX 10.7之后，OSX引入Color Emoji，这是苹果第一次在自己的桌面操作系统引入Emoji，用户可以直接在Mail或者iMessage之类的客户端直接输入Emoji字符。OSX（其实iOS也是用基本相同的实现）上的实现是通过一个叫做Apple Color Emoji的字体来实现的，这个字体文件被放在了&lt;code&gt;/System/Library/Fonts/Apple Color Emoji.ttf&lt;/code&gt;目录中。关于这个字体的细节，在Typophile中曾经有进行过相关的&lt;a href="http://typophile.com/node/83760"&gt;讨论&lt;/a&gt;，最后有工程师使用逆向工程分析了这个字体文件的格式，得出来的结论是，苹果扩展了OpenType标准，在ttf文件中直接嵌入了包含Emoji表情的图片，然后输入的时候通过根据Emoji表情的Unicode编码，找到对应的图片，将表情渲染出来。&lt;/p&gt;
&lt;p&gt;国外的程序员总是不用加班，因此他们很有空的研究了Apple Color Emoji的具体实现。前面提到，有工程逆向分析了Apple Color Emoji的采用的技术，下面我们来具体操作一下，最后我们可以提取出&lt;code&gt;Apple Color Emoji.ttf&lt;/code&gt;中的所有Emoji图片，以下的流程来自Typophile的一篇&lt;a href="http://typophile.com/node/103268"&gt;文章&lt;/a&gt;：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;安装FontTools，这是一个将ttf文件转换成xml，或者将xml转换成ttf文件的工具，使用python编写，如果已经安装了pip，可以通过&lt;code&gt;pip install FontTools&lt;/code&gt;来安装。&lt;/li&gt;
&lt;li&gt;上述文章中作者提供了一个FontTools的扩展，叫做&lt;code&gt;sbix_code.zip&lt;/code&gt;，&lt;a href="http://www.kutilek.de/download/sbix_code.zip"&gt;下载&lt;/a&gt;之后解压缩，将里面的文件复制到FontTools在python的site-packages目录下，如果是在OSX上，假设你使用的是python 2.7，那一般是在&lt;code&gt;/Library/Python/2.7/site-packages/FontTools&lt;/code&gt;目录下。&lt;/li&gt;
&lt;li&gt;该作者还提供了一个使用的demo：&lt;a href="http://www.kutilek.de/download/sbix_demo.zip"&gt;sbix_demo.zip&lt;/a&gt;，解压缩之后编辑里面的&lt;code&gt;extractSbixImages.py&lt;/code&gt;，修改如下：&lt;/li&gt;
&lt;/ul&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="ch"&gt;#! /usr/bin/env/python&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;fontTools.ttLib&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;TTFont&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;os.path&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;os&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="n"&gt;makedirs&lt;/span&gt;

&lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;main&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="n"&gt;f&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;TTFont&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;Apple Color Emoji.ttf&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;has_key&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;sbix&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;sbix&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;f&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;sbix&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
        &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;sbix&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bitmapSets&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;itervalues&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
            &lt;span class="n"&gt;setpath&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;extracted&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;set_&lt;/span&gt;&lt;span class="si"&gt;%i&lt;/span&gt;&lt;span class="s2"&gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="n"&gt;exists&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setpath&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
                &lt;span class="n"&gt;makedirs&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setpath&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;

            &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Writing bitmap set to &amp;lt;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;&amp;gt;&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;setpath&lt;/span&gt;
            &lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;bm&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="n"&gt;bs&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bitmaps&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;itervalues&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;bm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imageFormatTag&lt;/span&gt; &lt;span class="ow"&gt;is&lt;/span&gt; &lt;span class="ow"&gt;not&lt;/span&gt; &lt;span class="bp"&gt;None&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
                    &lt;span class="n"&gt;filename&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;join&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;setpath&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="s2"&gt;.png&amp;quot;&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="n"&gt;bm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;glyphName&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;pf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;file&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;filename&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;wb&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;write&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bm&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imageData&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
                    &lt;span class="n"&gt;pf&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;close&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Font has no sbix table.&amp;quot;&lt;/span&gt;

&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="vm"&gt;__name__&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;__main__&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
    &lt;span class="n"&gt;main&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;其中&lt;code&gt;"Apple Color Emoji.ttf"&lt;/code&gt;请改成Apple Color Emoji.ttf这个文件对应的目录&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;执行脚本，然后我们看到在同目录下多了一个叫做&lt;code&gt;extracted&lt;/code&gt;文件夹，里面分别存放着不同分辨率的Emoji表情图片：&lt;br /&gt;
&lt;img alt="" src="static/images/emojiFontList.png"&gt; &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;code&gt;set_**&lt;/code&gt;目录分辨对应不同的分辨率，可以看出，&lt;code&gt;Apple Color Emoji.ttf&lt;/code&gt;这个字体内嵌了多达8中不同分辨率的Emoji图片，难怪这个字体文件的大小达到了34M。&lt;/p&gt;
&lt;p&gt;非常感谢这位程序员的工作，使得我们能够一窥这个字体的大致实现，但是很可惜，这个实现是苹果自己的私有标准，没有合入到OpenType的正式标准中，而苹果官方对这里的实现也没有更多的资料，所以具体的技术标准，目前暂时找不到更加详细的资料。&lt;/p&gt;
&lt;h3&gt;Google Extension&lt;/h3&gt;
&lt;p&gt;Google一直以来都是程序员的救星，在Apple Color Emoji推出多年之后，在2013年，Google终于也推出了自己的开源Color Font标准：&lt;a href="http://google-opensource.blogspot.sg/2013/05/open-standard-color-font-fun-for.html"&gt;Open Standard Font Fun for Everyone
&lt;/a&gt;，Google同样扩展了OpenType的标准，并且提供了一个开源的实现：&lt;a href="https://code.google.com/p/color-emoji/"&gt;color-emoji&lt;/a&gt;。Google通过以下方式扩展OpenType，使其支持Color Emoji:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;复用在ttf文件结构中的EBDT/EBLC表，直接内嵌Emoji图片的ARGB信息到这两个表当中，根据Google的标准，目前采用的是每个像素24位来存储，以BGRA顺序存储。值得一提的是，在ttf文件中，这两个表本来就是设计用于内嵌图片数据的，用于小分辨率字体的渲染，本来一般每像素只用8位存储，因此只能存储黑白图片，详细可以看下微软的官方&lt;a href="http://www.microsoft.com/typography/otspec/ebdt.htm"&gt;资料&lt;/a&gt;，不过在这种情况下，内嵌的图片是未经压缩的。&lt;/li&gt;
&lt;li&gt;另外一种方法是Google在ttf文件中新增了两个表，叫做CBDT/CBLC，在这两个表中可以存储经过压缩的图片格式，目前只支持PNG这一种格式。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;em&gt;注：ttf文件的格式大致是以表为单位存储各种不同的数据，关于ttf文件的格式，可以查看微软的官方&lt;a href="http://www.microsoft.com/typography/otspec/otff.htm"&gt;资料&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;可以看出，Google的实现大致也苹果的类似，都是内嵌了图片在ttf文件中。而在Google提供的开源实现当中，主要包括以下几个项目的扩展：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;freetype的扩展，Google扩展了freetype这个库，使其支持Google的ttf扩展&lt;/li&gt;
&lt;li&gt;skia，支持freetype扩展之后的字体解析输出&lt;/li&gt;
&lt;li&gt;cairo，支持了freetype扩展之后的输出，并且对于不能渲染的状况，fallback成使用Xlib作为后端(cairo也是和skia一样的2D矢量绘图库，可以选择多个后端，例如选择OpenGL为后端可以实现硬件加速)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;其中，这个项目的freetype以及skia的实现被带入了Android 4.4中，也就是说，在Android 4.4之后的版本，我们终于可以像iOS一样使用Color Emoji Font了！！&lt;/p&gt;
&lt;h3&gt;Using in Android&lt;/h3&gt;
&lt;p&gt;上文提到，在Android 4.4之后，Google终于支持了Color Emoji Font，实际上，如果你用的是Google输入法，则可以发现在这个面板上输入到所有Google Style的Emoji表情：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/googleIME.png"&gt; &lt;/p&gt;
&lt;p&gt;但是，很明显，Google提供的Emoji字体的样式实在是太丑了，很多人还是喜欢原来苹果的Emoji样式：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/iosEmoji.jpg"&gt; &lt;/p&gt;
&lt;p&gt;既然Android 4.4之后新增了Color Emoji Font的支持，根据上面的叙述，我们是否可以自己制作一个iOS Style Emoji字体给我们使用呢，答案当然是可以了，在xda论坛上，已经有人进行了这种&lt;a href="http://forum.xda-developers.com/showthread.php?t=2563757"&gt;尝试&lt;/a&gt;，原理是利用OSX中的&lt;code&gt;Apple Color Emoji.ttf&lt;/code&gt;提取出来的图片，然后使用FontTools以及&lt;a href="https://code.google.com/p/color-emoji/"&gt;color-emoji&lt;/a&gt;项目中的相关脚本即可生成对应的ttf文件。&lt;/p&gt;
&lt;p&gt;由于整个生成过程比较复杂，涉及比较多的依赖，有兴趣的可以看下color-emoji项目中的example的Makefile文件的内容，可以看到每一步是怎么生成的，在这里由于篇幅有限就不再赘述了。根据此方法生成的ttf文件，大家可以在这里&lt;a href="http://pan.baidu.com/s/1kTLyqSB"&gt;下载&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;在生成了这个emoji字体文件之后，我们就可以直接在android中使用了，有以下两种方式：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;root了手机之后，更改系统的字体配置文件，使其作为系统的默认emoji字体。&lt;/li&gt;
&lt;li&gt;在TextView中使用setTypeface来设置字体，只要TextView中包含的内容含有emoji指定的unicode编码，就可以直接显示emoji表情了。&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;性能对比&lt;/h4&gt;
&lt;p&gt;对比起使用SpannableString那一套，直接通过setTypeface来显示emoji文字的性能差距究竟有多少呢？接下来我们来简单的测试一下。&lt;/p&gt;
&lt;p&gt;在测试用例的选择方面，我们选择一条3000多行的emoji表情字符串，算是一个非常极端例子（每个表情后面跟上一个换行符）：&lt;/p&gt;
&lt;p&gt;&lt;img alt="" src="static/images/emojiFontTestCase.png"&gt;&lt;/p&gt;
&lt;p&gt;测试基准为，从&lt;code&gt;startActivity&lt;/code&gt;开始，到包含表情的Activity的中展示emoji的TextView第一次调用&lt;code&gt;dispatchDraw&lt;/code&gt;方法为止所消耗的时间，测试的环境为Nexus 5，Android 5.0，测试10次，计算平均时间：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;使用Emoji Font，平均时间为&lt;strong&gt;433ms&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;使用SpannableString（不带cache），平均时间为&lt;strong&gt;9457ms&lt;/strong&gt;&lt;/li&gt;
&lt;li&gt;如果SpannableString带上cache之后，可以省去了重复setSpan的耗时了，此时的平均时间为&lt;strong&gt;8357ms&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;可以看出，Emoji Font比SpannableString的方案快了一个数量级，而且即使带上cache，使用SpannableString出来的效果也没有想象中好，究其原因，或许是由于在绘制时，getSpans操作中的反射消耗了大量时间。&lt;/p&gt;
&lt;h4&gt;Backport to pre-KitKat&lt;/h4&gt;
&lt;p&gt;Color Emoji Font是Android4.4才加上的新功能，那对于4.4之前的版本，有没有办法也能使用Emoji Font呢，我想到了两点，但似乎都不大可行：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;将skia和freetype带入app中，使用其中的API去解析，然后构建一个Typeface给TextView使用。先不讨论是否可行，首先skia编译出来的so已经是非常大了，skia官方的android app demo中的的&lt;code&gt;libskia_android.so&lt;/code&gt;大小达到&lt;strong&gt;36M&lt;/strong&gt;，完全不可能放在普通app中。&lt;/li&gt;
&lt;li&gt;重造TextView，自行解析emoji符号，不使用SpannableString，而是直接画出来。使用这个方案之后，Emoji Font就不是必须的了，但重造TextView的成本也是太高了。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;因此，最终的结论仍然是开头中所说的，在android4.4以前，无法使用像iOS/OSX那样的Emoji Font，最简单的解决方案是使用ImageSpan配合SpannableString，而在4.4及之后的版本，则可以直接采用类似iOS/OSX的方案进行快速渲染。&lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;最后，祝愿Lollipop的光芒能够早日照亮天朝。&lt;/p&gt;</content></entry><entry><title>Re:Blog</title><link href="http://ragnraok.github.io/re-blog.html" rel="alternate"></link><published>2015-01-02T00:00:00+08:00</published><updated>2015-01-02T00:00:00+08:00</updated><author><name>Ragnarok Zhou</name></author><id>tag:ragnraok.github.io,2015-01-02:/re-blog.html</id><content type="html">&lt;p&gt;大二的时候，曾经写过一段时间的博客。当时还记得刚学python不久，兴高采烈的使用Django写了一个非常简单的博客引擎，在42qu买了个服务器，然后在Godaddy那里买了个域名，于是就火速在上面搭建了人生的第一个博客。&lt;/p&gt;
&lt;p&gt;一晃过去，已经是两年的时间了，原来的博客早已废弃，已经很久没有在博客上写过文字了。&lt;/p&gt;
&lt;p&gt;工作半年，这半年工作真的非常忙。越来越觉得缺少积累，而且慢慢地，也失去了当初在学校那种涉猎各种技术的激情，反而，作为Android开发者，在Android开发这里，进行了更加深入的研究。这让我想起了以前在学校有位老师跟我说过，在学校需要的时候更广的知识面，而到了工作，就需要更为深入的专研某个技术的实现，而对于Android以外的技术，已经没有那么多时间再去涉猎了，这或许是从BFS到DFS的转变吧。&lt;/p&gt;
&lt;p&gt;在以前的博客，即使我成功地实现了某个函数也会记录下来，在这里，除了技术，或许我会在这里记录一些生活的细节吧。&lt;/p&gt;
&lt;p&gt;思绪混乱，文笔一般，看客请注意。&lt;/p&gt;
&lt;p&gt;已经是2015年了，新的一年，希望通过这个博客，能够有个新的开始吧。&lt;/p&gt;
&lt;p&gt;&lt;em&gt;注：此博客由&lt;a href="https://github.com/getpelican/pelican"&gt;pelican&lt;/a&gt;搭建&lt;/em&gt;&lt;/p&gt;</content></entry></feed>